{"version":3,"sources":["../../../../../src/lib/core/style/focus-origin-monitor.ts"],"names":[],"mappings":"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","file":"focus-origin-monitor.js","sourceRoot":"","sourcesContent":["import {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  Optional,\n  Output,\n  Renderer,\n  SkipSelf\n} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Subject} from 'rxjs/Subject';\n\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nexport const /** @type {?} */ TOUCH_BUFFER_MS = 650;\n\n\nexport type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program';\n\n\ntype MonitoredElementInfo = {\n  unlisten: Function,\n  checkChildren: boolean,\n  renderer: Renderer,\n  subject: Subject<FocusOrigin>\n};\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nexport class FocusOriginMonitor {\n/**\n * The focus origin that the next focus event is a result of.\n */\nprivate _origin: FocusOrigin = null;\n/**\n * The FocusOrigin of the last focus event tracked by the FocusOriginMonitor.\n */\nprivate _lastFocusOrigin: FocusOrigin;\n/**\n * Whether the window has just been focused.\n */\nprivate _windowFocused = false;\n/**\n * The target of the last touch event.\n */\nprivate _lastTouchTarget: EventTarget;\n/**\n * The timeout id of the touch timeout, used to cancel timeout later.\n */\nprivate _touchTimeout: number;\n/**\n * Weak map of elements being monitored to their info.\n */\nprivate _elementInfo = new WeakMap<Element, MonitoredElementInfo>();\n/**\n * @param {?} _ngZone\n */\nconstructor(private _ngZone: NgZone) {\n    this._ngZone.runOutsideAngular(() => this._registerDocumentEvents());\n  }\n/**\n * Monitors focus on an element and applies appropriate CSS classes.\n * @param {?} element The element to monitor\n * @param {?} renderer The renderer to use to apply CSS classes to the element.\n * @param {?} checkChildren Whether to count the element as focused when its children are focused.\n * @return {?} An observable that emits when the focus state of the element changes.\n *     When the element is blurred, null will be emitted.\n */\nmonitor(element: Element, renderer: Renderer, checkChildren: boolean): Observable<FocusOrigin> {\n    // Check if we're already monitoring this element.\n    if (this._elementInfo.has(element)) {\n      let /** @type {?} */ info = this._elementInfo.get(element);\n      info.checkChildren = checkChildren;\n      return info.subject.asObservable();\n    }\n\n    // Create monitored element info.\n    let /** @type {?} */ info: MonitoredElementInfo = {\n      unlisten: null,\n      checkChildren: checkChildren,\n      renderer: renderer,\n      subject: new Subject<FocusOrigin>()\n    };\n    this._elementInfo.set(element, info);\n\n    // Start listening. We need to listen in capture phase since focus events don't bubble.\n    let /** @type {?} */ focusListener = (event: FocusEvent) => this._onFocus(event, element);\n    let /** @type {?} */ blurListener = (event: FocusEvent) => this._onBlur(event, element);\n    this._ngZone.runOutsideAngular(() => {\n      element.addEventListener('focus', focusListener, true);\n      element.addEventListener('blur', blurListener, true);\n    });\n\n    // Create an unlisten function for later.\n    info.unlisten = () => {\n      element.removeEventListener('focus', focusListener, true);\n      element.removeEventListener('blur', blurListener, true);\n    };\n\n    return info.subject.asObservable();\n  }\n/**\n * Stops monitoring an element and removes all focus classes.\n * @param {?} element The element to stop monitoring.\n * @return {?}\n */\nstopMonitoring(element: Element): void {\n    let /** @type {?} */ elementInfo = this._elementInfo.get(element);\n\n    if (elementInfo) {\n      elementInfo.unlisten();\n      elementInfo.subject.complete();\n\n      this._setClasses(element, null);\n      this._elementInfo.delete(element);\n    }\n  }\n/**\n * Focuses the element via the specified focus origin.\n * @param {?} element The element to focus.\n * @param {?} renderer The renderer to use to invoke the focus method on the element.\n * @param {?} origin The focus origin.\n * @return {?}\n */\nfocusVia(element: Node, renderer: Renderer, origin: FocusOrigin): void {\n    this._setOriginForCurrentEventQueue(origin);\n    renderer.invokeElementMethod(element, 'focus');\n  }\n/**\n * Register necessary event listeners on the document and window.\n * @return {?}\n */\nprivate _registerDocumentEvents() {\n    // Note: we listen to events in the capture phase so we can detect them even if the user stops\n    // propagation.\n\n    // On keydown record the origin and clear any touch event that may be in progress.\n    document.addEventListener('keydown', () => {\n      this._lastTouchTarget = null;\n      this._setOriginForCurrentEventQueue('keyboard');\n    }, true);\n\n    // On mousedown record the origin only if there is not touch target, since a mousedown can\n    // happen as a result of a touch event.\n    document.addEventListener('mousedown', () => {\n      if (!this._lastTouchTarget) {\n        this._setOriginForCurrentEventQueue('mouse');\n      }\n    }, true);\n\n    // When the touchstart event fires the focus event is not yet in the event queue. This means\n    // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n    // see if a focus happens.\n    document.addEventListener('touchstart', (event: Event) => {\n      if (this._touchTimeout != null) {\n        clearTimeout(this._touchTimeout);\n      }\n      this._lastTouchTarget = event.target;\n      this._touchTimeout = setTimeout(() => this._lastTouchTarget = null, TOUCH_BUFFER_MS);\n    }, true);\n\n    // Make a note of when the window regains focus, so we can restore the origin info for the\n    // focused element.\n    window.addEventListener('focus', () => {\n      this._windowFocused = true;\n      setTimeout(() => this._windowFocused = false, 0);\n    });\n  }\n/**\n * Sets the focus classes on the element based on the given focus origin.\n * @param {?} element The element to update the classes on.\n * @param {?} origin The focus origin.\n * @return {?}\n */\nprivate _setClasses(element: Element, origin: FocusOrigin): void {\n    let /** @type {?} */ renderer = this._elementInfo.get(element).renderer;\n    renderer.setElementClass(element, 'cdk-focused', !!origin);\n    renderer.setElementClass(element, 'cdk-touch-focused', origin === 'touch');\n    renderer.setElementClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n    renderer.setElementClass(element, 'cdk-mouse-focused', origin === 'mouse');\n    renderer.setElementClass(element, 'cdk-program-focused', origin === 'program');\n  }\n/**\n * Sets the origin and schedules an async function to clear it at the end of the event queue.\n * @param {?} origin The origin to set.\n * @return {?}\n */\nprivate _setOriginForCurrentEventQueue(origin: FocusOrigin): void {\n    this._origin = origin;\n    setTimeout(() => this._origin = null, 0);\n  }\n/**\n * Checks whether the given focus event was caused by a touchstart event.\n * @param {?} event The focus event to check.\n * @return {?} Whether the event was caused by a touch.\n */\nprivate _wasCausedByTouch(event: FocusEvent): boolean {\n    // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n    // Consider the following dom structure:\n    //\n    // <div #parent tabindex=\"0\" cdkFocusClasses>\n    //   <div #child (click)=\"#parent.focus()\"></div>\n    // </div>\n    //\n    // If the user touches the #child element and the #parent is programmatically focused as a\n    // result, this code will still consider it to have been caused by the touch event and will\n    // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n    // relatively small edge-case that can be worked around by using\n    // focusVia(parentEl, renderer,  'program') to focus the parent element.\n    //\n    // If we decide that we absolutely must handle this case correctly, we can do so by listening\n    // for the first focus event after the touchstart, and then the first blur event after that\n    // focus event. When that blur event fires we know that whatever follows is not a result of the\n    // touchstart.\n    let /** @type {?} */ focusTarget = event.target;\n    return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n        (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n  }\n/**\n * Handles focus events on a registered element.\n * @param {?} event The focus event.\n * @param {?} element The monitored element.\n * @return {?}\n */\nprivate _onFocus(event: FocusEvent, element: Element) {\n    // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n    // focus event affecting the monitored element. If we want to use the origin of the first event\n    // instead we should check for the cdk-focused class here and return if the element already has\n    // it. (This only matters for elements that have includesChildren = true).\n\n    // If we are not counting child-element-focus as focused, make sure that the event target is the\n    // monitored element itself.\n    if (!this._elementInfo.get(element).checkChildren && element !== event.target) {\n      return;\n    }\n\n    // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n    // 1) The window has just regained focus, in which case we want to restore the focused state of\n    //    the element from before the window blurred.\n    // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n    // 3) The element was programmatically focused, in which case we should mark the origin as\n    //    'program'.\n    if (!this._origin) {\n      if (this._windowFocused && this._lastFocusOrigin) {\n        this._origin = this._lastFocusOrigin;\n      } else if (this._wasCausedByTouch(event)) {\n        this._origin = 'touch';\n      } else {\n        this._origin = 'program';\n      }\n    }\n\n    this._setClasses(element, this._origin);\n    this._elementInfo.get(element).subject.next(this._origin);\n    this._lastFocusOrigin = this._origin;\n    this._origin = null;\n  }\n/**\n * Handles blur events on a registered element.\n * @param {?} event The blur event.\n * @param {?} element The monitored element.\n * @return {?}\n */\nprivate _onBlur(event: FocusEvent, element: Element) {\n    // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n    // order to focus another child of the monitored element.\n    if (this._elementInfo.get(element).checkChildren && event.relatedTarget instanceof Node &&\n        element.contains(event.relatedTarget)) {\n      return;\n    }\n\n    this._setClasses(element, null);\n    this._elementInfo.get(element).subject.next(null);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: NgZone, },\n];\n}\n\nfunction FocusOriginMonitor_tsickle_Closure_declarations() {\n/** @type {?} */\nFocusOriginMonitor.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nFocusOriginMonitor.ctorParameters;\n/**\n * The focus origin that the next focus event is a result of.\n * @type {?}\n */\nFocusOriginMonitor.prototype._origin;\n/**\n * The FocusOrigin of the last focus event tracked by the FocusOriginMonitor.\n * @type {?}\n */\nFocusOriginMonitor.prototype._lastFocusOrigin;\n/**\n * Whether the window has just been focused.\n * @type {?}\n */\nFocusOriginMonitor.prototype._windowFocused;\n/**\n * The target of the last touch event.\n * @type {?}\n */\nFocusOriginMonitor.prototype._lastTouchTarget;\n/**\n * The timeout id of the touch timeout, used to cancel timeout later.\n * @type {?}\n */\nFocusOriginMonitor.prototype._touchTimeout;\n/**\n * Weak map of elements being monitored to their info.\n * @type {?}\n */\nFocusOriginMonitor.prototype._elementInfo;\n/** @type {?} */\nFocusOriginMonitor.prototype._ngZone;\n}\n\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n * \n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nexport class CdkMonitorFocus implements OnDestroy {\n  \n  cdkFocusChange = new EventEmitter<FocusOrigin>();\n/**\n * @param {?} _elementRef\n * @param {?} _focusOriginMonitor\n * @param {?} renderer\n */\nconstructor(private _elementRef: ElementRef,\nprivate _focusOriginMonitor: FocusOriginMonitor,\n              renderer: Renderer) {\n    this._focusOriginMonitor.monitor(\n        this._elementRef.nativeElement, renderer,\n        this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n        .subscribe(origin => this.cdkFocusChange.emit(origin));\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this._focusOriginMonitor.stopMonitoring(this._elementRef.nativeElement);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: FocusOriginMonitor, },\n{type: Renderer, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'cdkFocusChange': [{ type: Output },],\n};\n}\n\nfunction CdkMonitorFocus_tsickle_Closure_declarations() {\n/** @type {?} */\nCdkMonitorFocus.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nCdkMonitorFocus.ctorParameters;\n/** @type {?} */\nCdkMonitorFocus.propDecorators;\n/** @type {?} */\nCdkMonitorFocus.prototype.cdkFocusChange;\n/** @type {?} */\nCdkMonitorFocus.prototype._elementRef;\n/** @type {?} */\nCdkMonitorFocus.prototype._focusOriginMonitor;\n}\n\n/**\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @return {?}\n */\nexport function FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY(parentDispatcher: FocusOriginMonitor,\n                                                      ngZone: NgZone) {\n  return parentDispatcher || new FocusOriginMonitor(ngZone);\n}\n\n\nexport const /** @type {?} */ FOCUS_ORIGIN_MONITOR_PROVIDER = {\n  // If there is already a FocusOriginMonitor available, use that. Otherwise, provide a new one.\n  provide: FocusOriginMonitor,\n  deps: [[new Optional(), new SkipSelf(), FocusOriginMonitor], NgZone],\n  useFactory: FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY\n};\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}