{"version":3,"sources":["../../../../../src/lib/core/a11y/list-key-manager.ts"],"names":[],"mappings":"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","file":"list-key-manager.js","sourceRoot":"","sourcesContent":["import {QueryList} from '@angular/core';\nimport {UP_ARROW, DOWN_ARROW, TAB, HOME, END} from '../core';\nimport {Observable} from 'rxjs/Observable';\nimport {Subject} from 'rxjs/Subject';\n\n/**\n * This interface is for items that can be disabled. The type passed into\n * ListKeyManager must extend this interface.\n */\nexport interface CanDisable {\n  disabled?: boolean;\n}\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends CanDisable> {\nprivate _activeItemIndex: number = null;\nprivate _activeItem: T;\nprivate _tabOut: Subject<any> = new Subject();\nprivate _wrap: boolean = false;\n/**\n * @param {?} _items\n */\nconstructor(private _items: QueryList<T>) {\n  }\n/**\n * Turns on wrapping mode, which ensures that the active item will wrap to\n * the other end of list when there are no more items in the given direction.\n * \n * @return {?} The ListKeyManager that the method was called on.\n */\nwithWrap(): this {\n    this._wrap = true;\n    return this;\n  }\n/**\n * Sets the active item to the item at the index specified.\n * \n * @param {?} index The index of the item to be set as active.\n * @return {?}\n */\nsetActiveItem(index: number): void {\n    this._activeItemIndex = index;\n    this._activeItem = this._items.toArray()[index];\n  }\n/**\n * Sets the active item depending on the key event passed in.\n * @param {?} event Keyboard event to be used for determining which element should be active.\n * @return {?}\n */\nonKeydown(event: KeyboardEvent): void {\n    switch (event.keyCode) {\n      case DOWN_ARROW:\n        this.setNextItemActive();\n        break;\n      case UP_ARROW:\n        this.setPreviousItemActive();\n        break;\n      case HOME:\n        this.setFirstItemActive();\n        break;\n      case END:\n        this.setLastItemActive();\n        break;\n      case TAB:\n        // Note that we shouldn't prevent the default action on tab.\n        this._tabOut.next(null);\n        return;\n      default:\n        return;\n    }\n\n    event.preventDefault();\n  }\n/**\n * Returns the index of the currently active item.\n * @return {?}\n */\nget activeItemIndex(): number {\n    return this._activeItemIndex;\n  }\n/**\n * Returns the currently active item.\n * @return {?}\n */\nget activeItem(): T {\n    return this._activeItem;\n  }\n/**\n * Sets the active item to the first enabled item in the list.\n * @return {?}\n */\nsetFirstItemActive(): void {\n    this._setActiveItemByIndex(0, 1);\n  }\n/**\n * Sets the active item to the last enabled item in the list.\n * @return {?}\n */\nsetLastItemActive(): void {\n    this._setActiveItemByIndex(this._items.length - 1, -1);\n  }\n/**\n * Sets the active item to the next enabled item in the list.\n * @return {?}\n */\nsetNextItemActive(): void {\n    this._activeItemIndex === null ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n/**\n * Sets the active item to a previous enabled item in the list.\n * @return {?}\n */\nsetPreviousItemActive(): void {\n    this._activeItemIndex === null && this._wrap ? this.setLastItemActive()\n                                                 : this._setActiveItemByDelta(-1);\n  }\n/**\n * Allows setting of the activeItemIndex without any other effects.\n * @param {?} index The new activeItemIndex.\n * @return {?}\n */\nupdateActiveItemIndex(index: number) {\n    this._activeItemIndex = index;\n  }\n/**\n * Observable that emits any time the TAB key is pressed, so components can react\n * when focus is shifted off of the list.\n * @return {?}\n */\nget tabOut(): Observable<void> {\n    return this._tabOut.asObservable();\n  }\n/**\n * This method sets the active item, given a list of items and the delta between the\n * currently active item and the new active item. It will calculate differently\n * depending on whether wrap mode is turned on.\n * @param {?} delta\n * @param {?=} items\n * @return {?}\n */\nprivate _setActiveItemByDelta(delta: number, items = this._items.toArray()): void {\n    this._wrap ? this._setActiveInWrapMode(delta, items)\n               : this._setActiveInDefaultMode(delta, items);\n  }\n/**\n * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n * down the list until it finds an item that is not disabled, and it will wrap if it\n * encounters either end of the list.\n * @param {?} delta\n * @param {?} items\n * @return {?}\n */\nprivate _setActiveInWrapMode(delta: number, items: T[]): void {\n    // when active item would leave menu, wrap to beginning or end\n    this._activeItemIndex =\n      (this._activeItemIndex + delta + items.length) % items.length;\n\n    // skip all disabled menu items recursively until an enabled one is reached\n    if (items[this._activeItemIndex].disabled) {\n      this._setActiveInWrapMode(delta, items);\n    } else {\n      this.setActiveItem(this._activeItemIndex);\n    }\n  }\n/**\n * Sets the active item properly given the default mode. In other words, it will\n * continue to move down the list until it finds an item that is not disabled. If\n * it encounters either end of the list, it will stop and not wrap.\n * @param {?} delta\n * @param {?} items\n * @return {?}\n */\nprivate _setActiveInDefaultMode(delta: number, items: T[]): void {\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n  }\n/**\n * Sets the active item to the first enabled item starting at the index specified. If the\n * item is disabled, it will move in the fallbackDelta direction until it either\n * finds an enabled item or encounters the end of the list.\n * @param {?} index\n * @param {?} fallbackDelta\n * @param {?=} items\n * @return {?}\n */\nprivate _setActiveItemByIndex(index: number, fallbackDelta: number,\n                                  items = this._items.toArray()): void {\n    if (!items[index]) { return; }\n    while (items[index].disabled) {\n      index += fallbackDelta;\n      if (!items[index]) { return; }\n    }\n    this.setActiveItem(index);\n  }\n\n}\n\nfunction ListKeyManager_tsickle_Closure_declarations() {\n/** @type {?} */\nListKeyManager.prototype._activeItemIndex;\n/** @type {?} */\nListKeyManager.prototype._activeItem;\n/** @type {?} */\nListKeyManager.prototype._tabOut;\n/** @type {?} */\nListKeyManager.prototype._wrap;\n/** @type {?} */\nListKeyManager.prototype._items;\n}\n\n\n"]}