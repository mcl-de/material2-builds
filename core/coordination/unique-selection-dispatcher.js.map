{"version":3,"sources":["../../../../../src/lib/core/coordination/unique-selection-dispatcher.ts"],"names":[],"mappings":"AAAA,OAAO,EAAA,UAAE,EAAW,QAAA,EAAU,QAAA,EAAS,MAAA,eAAA,CAAA;AAKvC;;;;;;;;GAQG;AACH,MAEC;IAFD;QAGU,eAAA,GAAkD,EAAA,CAAG;IA0B/D,CAAC;IA3BD;;;;;OAKG;IACH,MAEG,CAAA,EAAA,EAAA,IAAA;QADC,GAAG,CAAC,CAAC,IAEC,gBAAA,CAAG,QAAA,IAAY,IAAA,CAAK,UAAC,CAAU,CAAC,CAAA;YADpC,QAAQ,CAEC,EAAC,EAAG,IAAA,CAAK,CAAC;QADrB,CAAC;IACH,CAAC;IACH;;;;OAIG;IACH,MADG,CAAA,QAAA;QAEC,IAAI,CADC,UAAC,CAAU,IAAC,CAAI,QAAC,CAAQ,CAAC;IAEjC,CAAC;;AAAI,oCAAA,GAAoC;IAE3C,EADE,IAAA,EAAM,UAAA,EAAW;CAElB,CADC;AAEF;;GAJE;AAID,wCAAA,GAAA,MAAA,EAIA,CAAC;AAGF;IACA,gBAAgB;IAChB,yBANa,CAAA,UAAA,CAAA;IAOb;;;OAGG;IACH,yBANG,CAAA,cAAA,CAAA;IAOH,gBAAgB;IAChB,yBAAyB,CAAC,SAAS,CAAC,UAAU,CAAC;AAC/C,CAAC;AAED;;;GAGG;AACH,MAnBC,uDAoBG,gBAA2C;IAC7C,MAAM,CAzBC,gBAAA,IAAoB,IAAI,yBAAA,EAA0B,CAAE;AA0B7D,CAAC;AAED,MAAM,CAzBC,MAAA,gBAAA,CAAM,oCAAA,GAAuC;IA0BlD,sFAAsF;IACtF,OAAO,EAzBE,yBAAA;IA0BT,IAAI,EAzBE,CAAA,CAAE,IAAI,QAAA,EAAS,EAAG,IAAI,QAAA,EAAS,EAAG,yBAAA,CAA0B,CAAC;IA0BnE,UAAU,EAzBE,4CAAA;CA0Bb,CAzBC","file":"unique-selection-dispatcher.js","sourceRoot":"","sourcesContent":["import {Injectable, Optional, SkipSelf} from '@angular/core';\n\n\n// Users of the Dispatcher never need to see this type, but TypeScript requires it to be exported.\nexport type UniqueSelectionDispatcherListener = (id: string, name: string) => void;\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n * \n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\nexport class UniqueSelectionDispatcher {\nprivate _listeners: UniqueSelectionDispatcherListener[] = [];\n/**\n * Notify other items that selection for the given name has been set.\n * @param {?} id ID of the item.\n * @param {?} name Name of the item.\n * @return {?}\n */\nnotify(id: string, name: string) {\n    for (let /** @type {?} */ listener of this._listeners) {\n      listener(id, name);\n    }\n  }\n/**\n * Listen for future changes to item selection.\n * @param {?} listener\n * @return {?}\n */\nlisten(listener: UniqueSelectionDispatcherListener) {\n    this._listeners.push(listener);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction UniqueSelectionDispatcher_tsickle_Closure_declarations() {\n/** @type {?} */\nUniqueSelectionDispatcher.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nUniqueSelectionDispatcher.ctorParameters;\n/** @type {?} */\nUniqueSelectionDispatcher.prototype._listeners;\n}\n\n/**\n * @param {?} parentDispatcher\n * @return {?}\n */\nexport function UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY(\n    parentDispatcher: UniqueSelectionDispatcher) {\n  return parentDispatcher || new UniqueSelectionDispatcher();\n}\n\nexport const /** @type {?} */ UNIQUE_SELECTION_DISPATCHER_PROVIDER = {\n  // If there is already a dispatcher available, use that. Otherwise, provide a new one.\n  provide: UniqueSelectionDispatcher,\n  deps: [[new Optional(), new SkipSelf(), UniqueSelectionDispatcher]],\n  useFactory: UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY\n};\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}