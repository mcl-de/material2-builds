{"version":3,"sources":["../../../../../../src/lib/core/overlay/position/connected-position-strategy.ts"],"names":[],"mappings":"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","file":"connected-position-strategy.js","sourceRoot":"","sourcesContent":["import {PositionStrategy} from './position-strategy';\nimport {ElementRef} from '@angular/core';\nimport {ViewportRuler} from './viewport-ruler';\nimport {\n  ConnectionPositionPair,\n  OriginConnectionPosition,\n  OverlayConnectionPosition,\n  ConnectedOverlayPositionChange, ScrollableViewProperties\n} from './connected-position';\nimport {Subject} from 'rxjs/Subject';\nimport {Observable} from 'rxjs/Observable';\nimport {Scrollable} from '../scroll/scrollable';\n\n/**\n * Container to hold the bounding positions of a particular element with respect to the viewport,\n * where top and bottom are the y-axis coordinates of the bounding rectangle and left and right are\n * the x-axis coordinates.\n */\nexport type ElementBoundingPositions = {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n};\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nexport class ConnectedPositionStrategy implements PositionStrategy {\nprivate _dir = 'ltr';\nprivate _offsetX: number = 0;\nprivate _offsetY: number = 0;\nprivate scrollables: Scrollable[] = [];\n/**\n * Whether the we're dealing with an RTL context\n * @return {?}\n */\nget _isRtl() {\n    return this._dir === 'rtl';\n  }\n\n  /** Ordered list of preferred positions, from most to least desirable. */\n  _preferredPositions: ConnectionPositionPair[] = [];\nprivate _origin: HTMLElement;\nprivate _pane: HTMLElement;\nprivate _lastConnectedPosition: ConnectionPositionPair;\n\n  _onPositionChange:\n      Subject<ConnectedOverlayPositionChange> = new Subject<ConnectedOverlayPositionChange>();\n/**\n * Emits an event when the connection point changes.\n * @return {?}\n */\nget onPositionChange(): Observable<ConnectedOverlayPositionChange> {\n    return this._onPositionChange.asObservable();\n  }\n/**\n * @param {?} _connectedTo\n * @param {?} _originPos\n * @param {?} _overlayPos\n * @param {?} _viewportRuler\n */\nconstructor(\nprivate _connectedTo: ElementRef,\nprivate _originPos: OriginConnectionPosition,\nprivate _overlayPos: OverlayConnectionPosition,\nprivate _viewportRuler: ViewportRuler) {\n    this._origin = this._connectedTo.nativeElement;\n    this.withFallbackPosition(_originPos, _overlayPos);\n  }\n/**\n * Ordered list of preferred positions, from most to least desirable.\n * @return {?}\n */\nget positions() {\n    return this._preferredPositions;\n  }\n/**\n * To be used to for any cleanup after the element gets destroyed.\n * @return {?}\n */\ndispose() { }\n/**\n * Updates the position of the overlay element, using whichever preferred position relative\n * to the origin fits on-screen.\n * \\@docs-private \n * \n * @param {?} element Element to which to apply the CSS styles.\n * @return {?} Resolves when the styles have been applied.\n */\napply(element: HTMLElement): Promise<void> {\n    // Cache the overlay pane element in case re-calculating position is necessary\n    this._pane = element;\n\n    // We need the bounding rects for the origin and the overlay to determine how to position\n    // the overlay relative to the origin.\n    const /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n    const /** @type {?} */ overlayRect = element.getBoundingClientRect();\n\n    // We use the viewport rect to determine whether a position would go off-screen.\n    const /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\n\n    // Fallback point if none of the fallbacks fit into the viewport.\n    let /** @type {?} */ fallbackPoint: OverlayPoint = null;\n\n    // We want to place the overlay in the first of the preferred positions such that the\n    // overlay fits on-screen.\n    for (let /** @type {?} */ pos of this._preferredPositions) {\n      // Get the (x, y) point of connection on the origin, and then use that to get the\n      // (top, left) coordinate for the overlay at `pos`.\n      let /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n      let /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);\n\n      // If the overlay in the calculated position fits on-screen, put it there and we're done.\n      if (overlayPoint.fitsInViewport) {\n        this._setElementPosition(element, overlayPoint);\n\n        // Save the last connected position in case the position needs to be re-calculated.\n        this._lastConnectedPosition = pos;\n\n        // Notify that the position has been changed along with its change properties.\n        const /** @type {?} */ scrollableViewProperties = this.getScrollableViewProperties(element);\n        const /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n\n        return Promise.resolve(null);\n      } else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n        fallbackPoint = overlayPoint;\n      }\n    }\n\n    // If none of the preferred positions were in the viewport, take the one\n    // with the largest visible area.\n    this._setElementPosition(element, fallbackPoint);\n\n    return Promise.resolve(null);\n  }\n/**\n * This re-aligns the overlay element with the trigger in its last calculated position,\n * even if a position higher in the \"preferred positions\" list would now fit. This\n * allows one to re-align the panel without changing the orientation of the panel.\n * @return {?}\n */\nrecalculateLastPosition(): void {\n    const /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n    const /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n    const /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\n    const /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n\n    let /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n    let /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, lastPosition);\n    this._setElementPosition(this._pane, overlayPoint);\n  }\n/**\n * Sets the list of Scrollable containers that host the origin element so that\n * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n * Scrollable must be an ancestor element of the strategy's origin element.\n * @param {?} scrollables\n * @return {?}\n */\nwithScrollableContainers(scrollables: Scrollable[]) {\n    this.scrollables = scrollables;\n  }\n/**\n * Adds a new preferred fallback position.\n * @param {?} originPos\n * @param {?} overlayPos\n * @return {?}\n */\nwithFallbackPosition(\n      originPos: OriginConnectionPosition,\n      overlayPos: OverlayConnectionPosition): this {\n    this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));\n    return this;\n  }\n/**\n * Sets the layout direction so the overlay's position can be adjusted to match.\n * @param {?} dir New layout direction.\n * @return {?}\n */\nwithDirection(dir: 'ltr' | 'rtl'): this {\n    this._dir = dir;\n    return this;\n  }\n/**\n * Sets an offset for the overlay's connection point on the x-axis\n * @param {?} offset New offset in the X axis.\n * @return {?}\n */\nwithOffsetX(offset: number): this {\n    this._offsetX = offset;\n    return this;\n  }\n/**\n * Sets an offset for the overlay's connection point on the y-axis\n * @param {?} offset New offset in the Y axis.\n * @return {?}\n */\nwithOffsetY(offset: number): this {\n    this._offsetY = offset;\n    return this;\n  }\n/**\n * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n * @param {?} rect\n * @return {?}\n */\nprivate _getStartX(rect: ClientRect): number {\n    return this._isRtl ? rect.right : rect.left;\n  }\n/**\n * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n * @param {?} rect\n * @return {?}\n */\nprivate _getEndX(rect: ClientRect): number {\n    return this._isRtl ? rect.left : rect.right;\n  }\n/**\n * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n * @param {?} originRect\n * @param {?} pos\n * @return {?}\n */\nprivate _getOriginConnectionPoint(originRect: ClientRect, pos: ConnectionPositionPair): Point {\n    const /** @type {?} */ originStartX = this._getStartX(originRect);\n    const /** @type {?} */ originEndX = this._getEndX(originRect);\n\n    let /** @type {?} */ x: number;\n    if (pos.originX == 'center') {\n      x = originStartX + (originRect.width / 2);\n    } else {\n      x = pos.originX == 'start' ? originStartX : originEndX;\n    }\n\n    let /** @type {?} */ y: number;\n    if (pos.originY == 'center') {\n      y = originRect.top + (originRect.height / 2);\n    } else {\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n    }\n\n    return {x, y};\n  }\n/**\n * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n * origin point to which the overlay should be connected, as well as how much of the element\n * would be inside the viewport at that position.\n * @param {?} originPoint\n * @param {?} overlayRect\n * @param {?} viewportRect\n * @param {?} pos\n * @return {?}\n */\nprivate _getOverlayPoint(\n      originPoint: Point,\n      overlayRect: ClientRect,\n      viewportRect: ClientRect,\n      pos: ConnectionPositionPair): OverlayPoint {\n    // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n    // relative to the origin point.\n    let /** @type {?} */ overlayStartX: number;\n    if (pos.overlayX == 'center') {\n      overlayStartX = -overlayRect.width / 2;\n    } else if (pos.overlayX === 'start') {\n      overlayStartX = this._isRtl ? -overlayRect.width : 0;\n    } else {\n      overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n    }\n\n    let /** @type {?} */ overlayStartY: number;\n    if (pos.overlayY == 'center') {\n      overlayStartY = -overlayRect.height / 2;\n    } else {\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n    }\n\n    // The (x, y) coordinates of the overlay.\n    let /** @type {?} */ x = originPoint.x + overlayStartX + this._offsetX;\n    let /** @type {?} */ y = originPoint.y + overlayStartY + this._offsetY;\n\n    // How much the overlay would overflow at this position, on each side.\n    let /** @type {?} */ leftOverflow = 0 - x;\n    let /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportRect.width;\n    let /** @type {?} */ topOverflow = 0 - y;\n    let /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportRect.height;\n\n    // Visible parts of the element on each axis.\n    let /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n    let /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n\n    // The area of the element that's within the viewport.\n    let /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n    let /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n\n    return {x, y, fitsInViewport, visibleArea};\n  }\n/**\n * Gets the view properties of the trigger and overlay, including whether they are clipped\n * or completely outside the view of any of the strategy's scrollables.\n * @param {?} overlay\n * @return {?}\n */\nprivate getScrollableViewProperties(overlay: HTMLElement): ScrollableViewProperties {\n    const /** @type {?} */ originBounds = this._getElementBounds(this._origin);\n    const /** @type {?} */ overlayBounds = this._getElementBounds(overlay);\n    const /** @type {?} */ scrollContainerBounds = this.scrollables.map((scrollable: Scrollable) => {\n      return this._getElementBounds(scrollable.getElementRef().nativeElement);\n    });\n\n    return {\n      isOriginClipped: this.isElementClipped(originBounds, scrollContainerBounds),\n      isOriginOutsideView: this.isElementOutsideView(originBounds, scrollContainerBounds),\n      isOverlayClipped: this.isElementClipped(overlayBounds, scrollContainerBounds),\n      isOverlayOutsideView: this.isElementOutsideView(overlayBounds, scrollContainerBounds),\n    };\n  }\n/**\n * Whether the element is completely out of the view of any of the containers.\n * @param {?} elementBounds\n * @param {?} containersBounds\n * @return {?}\n */\nprivate isElementOutsideView(\n      elementBounds: ElementBoundingPositions,\n      containersBounds: ElementBoundingPositions[]): boolean {\n    return containersBounds.some((containerBounds: ElementBoundingPositions) => {\n      const /** @type {?} */ outsideAbove = elementBounds.bottom < containerBounds.top;\n      const /** @type {?} */ outsideBelow = elementBounds.top > containerBounds.bottom;\n      const /** @type {?} */ outsideLeft = elementBounds.right < containerBounds.left;\n      const /** @type {?} */ outsideRight = elementBounds.left > containerBounds.right;\n\n      return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n  }\n/**\n * Whether the element is clipped by any of the containers.\n * @param {?} elementBounds\n * @param {?} containersBounds\n * @return {?}\n */\nprivate isElementClipped(\n      elementBounds: ElementBoundingPositions,\n      containersBounds: ElementBoundingPositions[]): boolean {\n    return containersBounds.some((containerBounds: ElementBoundingPositions) => {\n      const /** @type {?} */ clippedAbove = elementBounds.top < containerBounds.top;\n      const /** @type {?} */ clippedBelow = elementBounds.bottom > containerBounds.bottom;\n      const /** @type {?} */ clippedLeft = elementBounds.left < containerBounds.left;\n      const /** @type {?} */ clippedRight = elementBounds.right > containerBounds.right;\n\n      return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n  }\n/**\n * Physically positions the overlay element to the given coordinate.\n * @param {?} element\n * @param {?} overlayPoint\n * @return {?}\n */\nprivate _setElementPosition(element: HTMLElement, overlayPoint: Point) {\n    element.style.left = overlayPoint.x + 'px';\n    element.style.top = overlayPoint.y + 'px';\n  }\n/**\n * Returns the bounding positions of the provided element with respect to the viewport.\n * @param {?} element\n * @return {?}\n */\nprivate _getElementBounds(element: HTMLElement): ElementBoundingPositions {\n    const /** @type {?} */ boundingClientRect = element.getBoundingClientRect();\n    return {\n      top: boundingClientRect.top,\n      right: boundingClientRect.left + boundingClientRect.width,\n      bottom: boundingClientRect.top + boundingClientRect.height,\n      left: boundingClientRect.left\n    };\n  }\n/**\n * Subtracts the amount that an element is overflowing on an axis from it's length.\n * @param {?} length\n * @param {...?} overflows\n * @return {?}\n */\nprivate _subtractOverflows(length: number, ...overflows: number[]): number {\n    return overflows.reduce((currentValue: number, currentOverflow: number) => {\n      return currentValue - Math.max(currentOverflow, 0);\n    }, length);\n  }\n}\n\nfunction ConnectedPositionStrategy_tsickle_Closure_declarations() {\n/** @type {?} */\nConnectedPositionStrategy.prototype._dir;\n/**\n * The offset in pixels for the overlay connection point on the x-axis\n * @type {?}\n */\nConnectedPositionStrategy.prototype._offsetX;\n/**\n * The offset in pixels for the overlay connection point on the y-axis\n * @type {?}\n */\nConnectedPositionStrategy.prototype._offsetY;\n/**\n * The Scrollable containers used to check scrollable view properties on position change.\n * @type {?}\n */\nConnectedPositionStrategy.prototype.scrollables;\n/**\n * Ordered list of preferred positions, from most to least desirable.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._preferredPositions;\n/**\n * The origin element against which the overlay will be positioned.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._origin;\n/**\n * The overlay pane element.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._pane;\n/**\n * The last position to have been calculated as the best fit position.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._lastConnectedPosition;\n/** @type {?} */\nConnectedPositionStrategy.prototype._onPositionChange;\n/** @type {?} */\nConnectedPositionStrategy.prototype._connectedTo;\n/** @type {?} */\nConnectedPositionStrategy.prototype._originPos;\n/** @type {?} */\nConnectedPositionStrategy.prototype._overlayPos;\n/** @type {?} */\nConnectedPositionStrategy.prototype._viewportRuler;\n}\n\n\n/** A simple (x, y) coordinate. */\ninterface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * Expands the simple (x, y) coordinate by adding info about whether the\n * element would fit inside the viewport at that position, as well as\n * how much of the element would be visible.\n */\ninterface OverlayPoint extends Point {\n  visibleArea?: number;\n  fitsInViewport?: boolean;\n}\n"]}