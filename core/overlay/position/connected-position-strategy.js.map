{"version":3,"sources":["../../../../../../src/lib/core/overlay/position/connected-position-strategy.ts"],"names":[],"mappings":"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","file":"connected-position-strategy.js","sourceRoot":"","sourcesContent":["import {PositionStrategy} from './position-strategy';\nimport {ElementRef} from '@angular/core';\nimport {ViewportRuler} from './viewport-ruler';\nimport {\n  ConnectionPositionPair,\n  OriginConnectionPosition,\n  OverlayConnectionPosition,\n  ConnectedOverlayPositionChange, ScrollableViewProperties\n} from './connected-position';\nimport {Subject} from 'rxjs/Subject';\nimport {Observable} from 'rxjs/Observable';\nimport {Scrollable} from '../scroll/scrollable';\n\n/**\n * Container to hold the bounding positions of a particular element with respect to the viewport,\n * where top and bottom are the y-axis coordinates of the bounding rectangle and left and right are\n * the x-axis coordinates.\n */\nexport type ElementBoundingPositions = {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n};\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nexport class ConnectedPositionStrategy implements PositionStrategy {\nprivate _dir = 'ltr';\n/**\n * The offset in pixels for the overlay connection point on the x-axis\n */\nprivate _offsetX: number = 0;\n/**\n * The offset in pixels for the overlay connection point on the y-axis\n */\nprivate _offsetY: number = 0;\n/**\n * The Scrollable containers used to check scrollable view properties on position change.\n */\nprivate scrollables: Scrollable[] = [];\n/**\n * Whether the we're dealing with an RTL context\n * @return {?}\n */\nget _isRtl() {\n    return this._dir === 'rtl';\n  }\n/**\n * Ordered list of preferred positions, from most to least desirable.\n */\n_preferredPositions: ConnectionPositionPair[] = [];\n/**\n * The origin element against which the overlay will be positioned.\n */\nprivate _origin: HTMLElement;\n/**\n * The overlay pane element.\n */\nprivate _pane: HTMLElement;\n/**\n * The last position to have been calculated as the best fit position.\n */\nprivate _lastConnectedPosition: ConnectionPositionPair;\n\n  _onPositionChange:\n      Subject<ConnectedOverlayPositionChange> = new Subject<ConnectedOverlayPositionChange>();\n/**\n * Emits an event when the connection point changes.\n * @return {?}\n */\nget onPositionChange(): Observable<ConnectedOverlayPositionChange> {\n    return this._onPositionChange.asObservable();\n  }\n/**\n * @param {?} _connectedTo\n * @param {?} _originPos\n * @param {?} _overlayPos\n * @param {?} _viewportRuler\n */\nconstructor(\nprivate _connectedTo: ElementRef,\nprivate _originPos: OriginConnectionPosition,\nprivate _overlayPos: OverlayConnectionPosition,\nprivate _viewportRuler: ViewportRuler) {\n    this._origin = this._connectedTo.nativeElement;\n    this.withFallbackPosition(_originPos, _overlayPos);\n  }\n/**\n * Ordered list of preferred positions, from most to least desirable.\n * @return {?}\n */\nget positions() {\n    return this._preferredPositions;\n  }\n/**\n * To be used to for any cleanup after the element gets destroyed.\n * @return {?}\n */\ndispose() { }\n/**\n * Updates the position of the overlay element, using whichever preferred position relative\n * to the origin fits on-screen.\n * \\@docs-private \n * \n * @param {?} element Element to which to apply the CSS styles.\n * @return {?} Resolves when the styles have been applied.\n */\napply(element: HTMLElement): Promise<void> {\n    // Cache the overlay pane element in case re-calculating position is necessary\n    this._pane = element;\n\n    // We need the bounding rects for the origin and the overlay to determine how to position\n    // the overlay relative to the origin.\n    const /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n    const /** @type {?} */ overlayRect = element.getBoundingClientRect();\n\n    // We use the viewport rect to determine whether a position would go off-screen.\n    const /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\n\n    // Fallback point if none of the fallbacks fit into the viewport.\n    let /** @type {?} */ fallbackPoint: OverlayPoint = null;\n\n    // We want to place the overlay in the first of the preferred positions such that the\n    // overlay fits on-screen.\n    for (let /** @type {?} */ pos of this._preferredPositions) {\n      // Get the (x, y) point of connection on the origin, and then use that to get the\n      // (top, left) coordinate for the overlay at `pos`.\n      let /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n      let /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);\n\n      // If the overlay in the calculated position fits on-screen, put it there and we're done.\n      if (overlayPoint.fitsInViewport) {\n        this._setElementPosition(element, overlayPoint);\n\n        // Save the last connected position in case the position needs to be re-calculated.\n        this._lastConnectedPosition = pos;\n\n        // Notify that the position has been changed along with its change properties.\n        const /** @type {?} */ scrollableViewProperties = this.getScrollableViewProperties(element);\n        const /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n\n        return Promise.resolve(null);\n      } else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n        fallbackPoint = overlayPoint;\n      }\n    }\n\n    // If none of the preferred positions were in the viewport, take the one\n    // with the largest visible area.\n    this._setElementPosition(element, fallbackPoint);\n\n    return Promise.resolve(null);\n  }\n/**\n * This re-aligns the overlay element with the trigger in its last calculated position,\n * even if a position higher in the \"preferred positions\" list would now fit. This\n * allows one to re-align the panel without changing the orientation of the panel.\n * @return {?}\n */\nrecalculateLastPosition(): void {\n    const /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n    const /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n    const /** @type {?} */ viewportRect = this._viewportRuler.getViewportRect();\n    const /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n\n    let /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n    let /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, lastPosition);\n    this._setElementPosition(this._pane, overlayPoint);\n  }\n/**\n * Sets the list of Scrollable containers that host the origin element so that\n * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n * Scrollable must be an ancestor element of the strategy's origin element.\n * @param {?} scrollables\n * @return {?}\n */\nwithScrollableContainers(scrollables: Scrollable[]) {\n    this.scrollables = scrollables;\n  }\n/**\n * Adds a new preferred fallback position.\n * @param {?} originPos\n * @param {?} overlayPos\n * @return {?}\n */\nwithFallbackPosition(\n      originPos: OriginConnectionPosition,\n      overlayPos: OverlayConnectionPosition): this {\n    this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));\n    return this;\n  }\n/**\n * Sets the layout direction so the overlay's position can be adjusted to match.\n * @param {?} dir New layout direction.\n * @return {?}\n */\nwithDirection(dir: 'ltr' | 'rtl'): this {\n    this._dir = dir;\n    return this;\n  }\n/**\n * Sets an offset for the overlay's connection point on the x-axis\n * @param {?} offset New offset in the X axis.\n * @return {?}\n */\nwithOffsetX(offset: number): this {\n    this._offsetX = offset;\n    return this;\n  }\n/**\n * Sets an offset for the overlay's connection point on the y-axis\n * @param {?} offset New offset in the Y axis.\n * @return {?}\n */\nwithOffsetY(offset: number): this {\n    this._offsetY = offset;\n    return this;\n  }\n/**\n * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n * @param {?} rect\n * @return {?}\n */\nprivate _getStartX(rect: ClientRect): number {\n    return this._isRtl ? rect.right : rect.left;\n  }\n/**\n * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n * @param {?} rect\n * @return {?}\n */\nprivate _getEndX(rect: ClientRect): number {\n    return this._isRtl ? rect.left : rect.right;\n  }\n/**\n * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n * @param {?} originRect\n * @param {?} pos\n * @return {?}\n */\nprivate _getOriginConnectionPoint(originRect: ClientRect, pos: ConnectionPositionPair): Point {\n    const /** @type {?} */ originStartX = this._getStartX(originRect);\n    const /** @type {?} */ originEndX = this._getEndX(originRect);\n\n    let /** @type {?} */ x: number;\n    if (pos.originX == 'center') {\n      x = originStartX + (originRect.width / 2);\n    } else {\n      x = pos.originX == 'start' ? originStartX : originEndX;\n    }\n\n    let /** @type {?} */ y: number;\n    if (pos.originY == 'center') {\n      y = originRect.top + (originRect.height / 2);\n    } else {\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n    }\n\n    return {x, y};\n  }\n/**\n * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n * origin point to which the overlay should be connected, as well as how much of the element\n * would be inside the viewport at that position.\n * @param {?} originPoint\n * @param {?} overlayRect\n * @param {?} viewportRect\n * @param {?} pos\n * @return {?}\n */\nprivate _getOverlayPoint(\n      originPoint: Point,\n      overlayRect: ClientRect,\n      viewportRect: ClientRect,\n      pos: ConnectionPositionPair): OverlayPoint {\n    // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n    // relative to the origin point.\n    let /** @type {?} */ overlayStartX: number;\n    if (pos.overlayX == 'center') {\n      overlayStartX = -overlayRect.width / 2;\n    } else if (pos.overlayX === 'start') {\n      overlayStartX = this._isRtl ? -overlayRect.width : 0;\n    } else {\n      overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n    }\n\n    let /** @type {?} */ overlayStartY: number;\n    if (pos.overlayY == 'center') {\n      overlayStartY = -overlayRect.height / 2;\n    } else {\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n    }\n\n    // The (x, y) coordinates of the overlay.\n    let /** @type {?} */ x = originPoint.x + overlayStartX + this._offsetX;\n    let /** @type {?} */ y = originPoint.y + overlayStartY + this._offsetY;\n\n    // How much the overlay would overflow at this position, on each side.\n    let /** @type {?} */ leftOverflow = 0 - x;\n    let /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportRect.width;\n    let /** @type {?} */ topOverflow = 0 - y;\n    let /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportRect.height;\n\n    // Visible parts of the element on each axis.\n    let /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n    let /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n\n    // The area of the element that's within the viewport.\n    let /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n    let /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n\n    return {x, y, fitsInViewport, visibleArea};\n  }\n/**\n * Gets the view properties of the trigger and overlay, including whether they are clipped\n * or completely outside the view of any of the strategy's scrollables.\n * @param {?} overlay\n * @return {?}\n */\nprivate getScrollableViewProperties(overlay: HTMLElement): ScrollableViewProperties {\n    const /** @type {?} */ originBounds = this._getElementBounds(this._origin);\n    const /** @type {?} */ overlayBounds = this._getElementBounds(overlay);\n    const /** @type {?} */ scrollContainerBounds = this.scrollables.map((scrollable: Scrollable) => {\n      return this._getElementBounds(scrollable.getElementRef().nativeElement);\n    });\n\n    return {\n      isOriginClipped: this.isElementClipped(originBounds, scrollContainerBounds),\n      isOriginOutsideView: this.isElementOutsideView(originBounds, scrollContainerBounds),\n      isOverlayClipped: this.isElementClipped(overlayBounds, scrollContainerBounds),\n      isOverlayOutsideView: this.isElementOutsideView(overlayBounds, scrollContainerBounds),\n    };\n  }\n/**\n * Whether the element is completely out of the view of any of the containers.\n * @param {?} elementBounds\n * @param {?} containersBounds\n * @return {?}\n */\nprivate isElementOutsideView(\n      elementBounds: ElementBoundingPositions,\n      containersBounds: ElementBoundingPositions[]): boolean {\n    return containersBounds.some((containerBounds: ElementBoundingPositions) => {\n      const /** @type {?} */ outsideAbove = elementBounds.bottom < containerBounds.top;\n      const /** @type {?} */ outsideBelow = elementBounds.top > containerBounds.bottom;\n      const /** @type {?} */ outsideLeft = elementBounds.right < containerBounds.left;\n      const /** @type {?} */ outsideRight = elementBounds.left > containerBounds.right;\n\n      return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n  }\n/**\n * Whether the element is clipped by any of the containers.\n * @param {?} elementBounds\n * @param {?} containersBounds\n * @return {?}\n */\nprivate isElementClipped(\n      elementBounds: ElementBoundingPositions,\n      containersBounds: ElementBoundingPositions[]): boolean {\n    return containersBounds.some((containerBounds: ElementBoundingPositions) => {\n      const /** @type {?} */ clippedAbove = elementBounds.top < containerBounds.top;\n      const /** @type {?} */ clippedBelow = elementBounds.bottom > containerBounds.bottom;\n      const /** @type {?} */ clippedLeft = elementBounds.left < containerBounds.left;\n      const /** @type {?} */ clippedRight = elementBounds.right > containerBounds.right;\n\n      return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n  }\n/**\n * Physically positions the overlay element to the given coordinate.\n * @param {?} element\n * @param {?} overlayPoint\n * @return {?}\n */\nprivate _setElementPosition(element: HTMLElement, overlayPoint: Point) {\n    element.style.left = overlayPoint.x + 'px';\n    element.style.top = overlayPoint.y + 'px';\n  }\n/**\n * Returns the bounding positions of the provided element with respect to the viewport.\n * @param {?} element\n * @return {?}\n */\nprivate _getElementBounds(element: HTMLElement): ElementBoundingPositions {\n    const /** @type {?} */ boundingClientRect = element.getBoundingClientRect();\n    return {\n      top: boundingClientRect.top,\n      right: boundingClientRect.left + boundingClientRect.width,\n      bottom: boundingClientRect.top + boundingClientRect.height,\n      left: boundingClientRect.left\n    };\n  }\n/**\n * Subtracts the amount that an element is overflowing on an axis from it's length.\n * @param {?} length\n * @param {...?} overflows\n * @return {?}\n */\nprivate _subtractOverflows(length: number, ...overflows: number[]): number {\n    return overflows.reduce((currentValue: number, currentOverflow: number) => {\n      return currentValue - Math.max(currentOverflow, 0);\n    }, length);\n  }\n}\n\nfunction ConnectedPositionStrategy_tsickle_Closure_declarations() {\n/** @type {?} */\nConnectedPositionStrategy.prototype._dir;\n/**\n * The offset in pixels for the overlay connection point on the x-axis\n * @type {?}\n */\nConnectedPositionStrategy.prototype._offsetX;\n/**\n * The offset in pixels for the overlay connection point on the y-axis\n * @type {?}\n */\nConnectedPositionStrategy.prototype._offsetY;\n/**\n * The Scrollable containers used to check scrollable view properties on position change.\n * @type {?}\n */\nConnectedPositionStrategy.prototype.scrollables;\n/**\n * Ordered list of preferred positions, from most to least desirable.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._preferredPositions;\n/**\n * The origin element against which the overlay will be positioned.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._origin;\n/**\n * The overlay pane element.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._pane;\n/**\n * The last position to have been calculated as the best fit position.\n * @type {?}\n */\nConnectedPositionStrategy.prototype._lastConnectedPosition;\n/** @type {?} */\nConnectedPositionStrategy.prototype._onPositionChange;\n/** @type {?} */\nConnectedPositionStrategy.prototype._connectedTo;\n/** @type {?} */\nConnectedPositionStrategy.prototype._originPos;\n/** @type {?} */\nConnectedPositionStrategy.prototype._overlayPos;\n/** @type {?} */\nConnectedPositionStrategy.prototype._viewportRuler;\n}\n\n\n/** A simple (x, y) coordinate. */\ninterface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * Expands the simple (x, y) coordinate by adding info about whether the\n * element would fit inside the viewport at that position, as well as\n * how much of the element would be visible.\n */\ninterface OverlayPoint extends Point {\n  visibleArea?: number;\n  fitsInViewport?: boolean;\n}\n"]}