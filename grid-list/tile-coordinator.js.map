{"version":3,"sources":["../../../../src/lib/grid-list/tile-coordinator.ts"],"names":[],"mappings":"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","file":"tile-coordinator.js","sourceRoot":"","sourcesContent":["import {QueryList} from '@angular/core';\nimport {MdGridTile} from './grid-tile';\nimport {MdGridTileTooWideError} from './grid-list-errors';\n/**\n * Class for determining, from a list of tiles, the (row, col) position of each of those tiles\n * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)\n * because the tiles can have a rowspan.\n * \n * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid\n * large enough to accommodate it so that the tiles still render in the same order in which they\n * are given.\n * \n * The basis of the algorithm is the use of an array to track the already placed tiles. Each\n * element of the array corresponds to a column, and the value indicates how many cells in that\n * column are already occupied; zero indicates an empty cell. Moving \"down\" to the next row\n * decrements each value in the tracking array (indicating that the column is one cell closer to\n * being free).\n * \n * \\@docs-private\n */\nexport class TileCoordinator {\n/**\n * Tracking array (see class description).\n */\ntracker: number[];\n/**\n * Index at which the search for the next gap will start.\n */\ncolumnIndex: number = 0;\n/**\n * The current row index.\n */\nrowIndex: number = 0;\n/**\n * Gets the total number of rows occupied by tiles\n * @return {?}\n */\nget rowCount(): number { return this.rowIndex + 1; }\n/**\n * Gets the total span of rows occupied by tiles.\n * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2.\n * @return {?}\n */\nget rowspan() {\n    let /** @type {?} */ lastRowMax = Math.max(...this.tracker);\n    // if any of the tiles has a rowspan that pushes it beyond the total row count,\n    // add the difference to the rowcount\n    return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;\n  }\n/**\n * The computed (row, col) position of each tile (the output).\n */\npositions: TilePosition[];\n/**\n * @param {?} numColumns\n * @param {?} tiles\n */\nconstructor(numColumns: number, tiles: QueryList<MdGridTile>) {\n    this.tracker = new Array(numColumns);\n    this.tracker.fill(0, 0, this.tracker.length);\n\n    this.positions = tiles.map(tile => this._trackTile(tile));\n  }\n/**\n * Calculates the row and col position of a tile.\n * @param {?} tile\n * @return {?}\n */\nprivate _trackTile(tile: MdGridTile): TilePosition {\n    // Find a gap large enough for this tile.\n    let /** @type {?} */ gapStartIndex = this._findMatchingGap(tile.colspan);\n\n    // Place tile in the resulting gap.\n    this._markTilePosition(gapStartIndex, tile);\n\n    // The next time we look for a gap, the search will start at columnIndex, which should be\n    // immediately after the tile that has just been placed.\n    this.columnIndex = gapStartIndex + tile.colspan;\n\n    return new TilePosition(this.rowIndex, gapStartIndex);\n  }\n/**\n * Finds the next available space large enough to fit the tile.\n * @param {?} tileCols\n * @return {?}\n */\nprivate _findMatchingGap(tileCols: number): number {\n    if (tileCols > this.tracker.length) {\n      throw new MdGridTileTooWideError(tileCols, this.tracker.length);\n    }\n\n    // Start index is inclusive, end index is exclusive.\n    let /** @type {?} */ gapStartIndex = -1;\n    let /** @type {?} */ gapEndIndex = -1;\n\n    // Look for a gap large enough to fit the given tile. Empty spaces are marked with a zero.\n    do {\n      // If we've reached the end of the row, go to the next row.\n      if (this.columnIndex + tileCols > this.tracker.length) {\n        this._nextRow();\n        continue;\n      }\n\n      gapStartIndex = this.tracker.indexOf(0, this.columnIndex);\n\n      // If there are no more empty spaces in this row at all, move on to the next row.\n      if (gapStartIndex == -1) {\n        this._nextRow();\n        continue;\n      }\n\n      gapEndIndex = this._findGapEndIndex(gapStartIndex);\n\n      // If a gap large enough isn't found, we want to start looking immediately after the current\n      // gap on the next iteration.\n      this.columnIndex = gapStartIndex + 1;\n\n      // Continue iterating until we find a gap wide enough for this tile.\n    } while (gapEndIndex - gapStartIndex < tileCols);\n    return gapStartIndex;\n  }\n/**\n * Move \"down\" to the next row.\n * @return {?}\n */\nprivate _nextRow(): void {\n    this.columnIndex = 0;\n    this.rowIndex++;\n\n    // Decrement all spaces by one to reflect moving down one row.\n    for (let /** @type {?} */ i = 0; i < this.tracker.length; i++) {\n      this.tracker[i] = Math.max(0, this.tracker[i] - 1);\n    }\n  }\n/**\n * Finds the end index (exclusive) of a gap given the index from which to start looking.\n * The gap ends when a non-zero value is found.\n * @param {?} gapStartIndex\n * @return {?}\n */\nprivate _findGapEndIndex(gapStartIndex: number): number {\n    for (let /** @type {?} */ i = gapStartIndex + 1; i < this.tracker.length; i++) {\n      if (this.tracker[i] != 0) {\n        return i;\n      }\n    }\n\n    // The gap ends with the end of the row.\n    return this.tracker.length;\n  }\n/**\n * Update the tile tracker to account for the given tile in the given space.\n * @param {?} start\n * @param {?} tile\n * @return {?}\n */\nprivate _markTilePosition(start: number, tile: MdGridTile): void {\n    for (let /** @type {?} */ i = 0; i < tile.colspan; i++) {\n      this.tracker[start + i] = tile.rowspan;\n    }\n  }\n}\n\nfunction TileCoordinator_tsickle_Closure_declarations() {\n/**\n * Tracking array (see class description).\n * @type {?}\n */\nTileCoordinator.prototype.tracker;\n/**\n * Index at which the search for the next gap will start.\n * @type {?}\n */\nTileCoordinator.prototype.columnIndex;\n/**\n * The current row index.\n * @type {?}\n */\nTileCoordinator.prototype.rowIndex;\n/**\n * The computed (row, col) position of each tile (the output).\n * @type {?}\n */\nTileCoordinator.prototype.positions;\n}\n\n/**\n * Simple data structure for tile position (row, col).\n * \\@docs-private\n */\nexport class TilePosition {\n/**\n * @param {?} row\n * @param {?} col\n */\nconstructor(public row: number,\npublic col: number) {}\n}\n\nfunction TilePosition_tsickle_Closure_declarations() {\n/** @type {?} */\nTilePosition.prototype.row;\n/** @type {?} */\nTilePosition.prototype.col;\n}\n\n"]}