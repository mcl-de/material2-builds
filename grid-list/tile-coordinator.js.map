{"version":3,"sources":["../../../../src/lib/grid-list/tile-coordinator.ts"],"names":[],"mappings":"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","file":"tile-coordinator.js","sourceRoot":"","sourcesContent":["import {QueryList} from '@angular/core';\nimport {MdGridTile} from './grid-tile';\nimport {MdGridTileTooWideError} from './grid-list-errors';\n/**\n * Class for determining, from a list of tiles, the (row, col) position of each of those tiles\n * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)\n * because the tiles can have a rowspan.\n * \n * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid\n * large enough to accommodate it so that the tiles still render in the same order in which they\n * are given.\n * \n * The basis of the algorithm is the use of an array to track the already placed tiles. Each\n * element of the array corresponds to a column, and the value indicates how many cells in that\n * column are already occupied; zero indicates an empty cell. Moving \"down\" to the next row\n * decrements each value in the tracking array (indicating that the column is one cell closer to\n * being free).\n * \n * \\@docs-private\n */\nexport class TileCoordinator {\n  /** Tracking array (see class description). */\n  tracker: number[];\n\n  /** Index at which the search for the next gap will start. */\n  columnIndex: number = 0;\n\n  /** The current row index. */\n  rowIndex: number = 0;\n/**\n * Gets the total number of rows occupied by tiles\n * @return {?}\n */\nget rowCount(): number { return this.rowIndex + 1; }\n/**\n * Gets the total span of rows occupied by tiles.\n * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2.\n * @return {?}\n */\nget rowspan() {\n    let /** @type {?} */ lastRowMax = Math.max(...this.tracker);\n    // if any of the tiles has a rowspan that pushes it beyond the total row count,\n    // add the difference to the rowcount\n    return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;\n  }\n\n  /** The computed (row, col) position of each tile (the output). */\n  positions: TilePosition[];\n/**\n * @param {?} numColumns\n * @param {?} tiles\n */\nconstructor(numColumns: number, tiles: QueryList<MdGridTile>) {\n    this.tracker = new Array(numColumns);\n    this.tracker.fill(0, 0, this.tracker.length);\n\n    this.positions = tiles.map(tile => this._trackTile(tile));\n  }\n/**\n * Calculates the row and col position of a tile.\n * @param {?} tile\n * @return {?}\n */\nprivate _trackTile(tile: MdGridTile): TilePosition {\n    // Find a gap large enough for this tile.\n    let /** @type {?} */ gapStartIndex = this._findMatchingGap(tile.colspan);\n\n    // Place tile in the resulting gap.\n    this._markTilePosition(gapStartIndex, tile);\n\n    // The next time we look for a gap, the search will start at columnIndex, which should be\n    // immediately after the tile that has just been placed.\n    this.columnIndex = gapStartIndex + tile.colspan;\n\n    return new TilePosition(this.rowIndex, gapStartIndex);\n  }\n/**\n * Finds the next available space large enough to fit the tile.\n * @param {?} tileCols\n * @return {?}\n */\nprivate _findMatchingGap(tileCols: number): number {\n    if (tileCols > this.tracker.length) {\n      throw new MdGridTileTooWideError(tileCols, this.tracker.length);\n    }\n\n    // Start index is inclusive, end index is exclusive.\n    let /** @type {?} */ gapStartIndex = -1;\n    let /** @type {?} */ gapEndIndex = -1;\n\n    // Look for a gap large enough to fit the given tile. Empty spaces are marked with a zero.\n    do {\n      // If we've reached the end of the row, go to the next row.\n      if (this.columnIndex + tileCols > this.tracker.length) {\n        this._nextRow();\n        continue;\n      }\n\n      gapStartIndex = this.tracker.indexOf(0, this.columnIndex);\n\n      // If there are no more empty spaces in this row at all, move on to the next row.\n      if (gapStartIndex == -1) {\n        this._nextRow();\n        continue;\n      }\n\n      gapEndIndex = this._findGapEndIndex(gapStartIndex);\n\n      // If a gap large enough isn't found, we want to start looking immediately after the current\n      // gap on the next iteration.\n      this.columnIndex = gapStartIndex + 1;\n\n      // Continue iterating until we find a gap wide enough for this tile.\n    } while (gapEndIndex - gapStartIndex < tileCols);\n    return gapStartIndex;\n  }\n/**\n * Move \"down\" to the next row.\n * @return {?}\n */\nprivate _nextRow(): void {\n    this.columnIndex = 0;\n    this.rowIndex++;\n\n    // Decrement all spaces by one to reflect moving down one row.\n    for (let /** @type {?} */ i = 0; i < this.tracker.length; i++) {\n      this.tracker[i] = Math.max(0, this.tracker[i] - 1);\n    }\n  }\n/**\n * Finds the end index (exclusive) of a gap given the index from which to start looking.\n * The gap ends when a non-zero value is found.\n * @param {?} gapStartIndex\n * @return {?}\n */\nprivate _findGapEndIndex(gapStartIndex: number): number {\n    for (let /** @type {?} */ i = gapStartIndex + 1; i < this.tracker.length; i++) {\n      if (this.tracker[i] != 0) {\n        return i;\n      }\n    }\n\n    // The gap ends with the end of the row.\n    return this.tracker.length;\n  }\n/**\n * Update the tile tracker to account for the given tile in the given space.\n * @param {?} start\n * @param {?} tile\n * @return {?}\n */\nprivate _markTilePosition(start: number, tile: MdGridTile): void {\n    for (let /** @type {?} */ i = 0; i < tile.colspan; i++) {\n      this.tracker[start + i] = tile.rowspan;\n    }\n  }\n}\n\nfunction TileCoordinator_tsickle_Closure_declarations() {\n/**\n * Tracking array (see class description).\n * @type {?}\n */\nTileCoordinator.prototype.tracker;\n/**\n * Index at which the search for the next gap will start.\n * @type {?}\n */\nTileCoordinator.prototype.columnIndex;\n/**\n * The current row index.\n * @type {?}\n */\nTileCoordinator.prototype.rowIndex;\n/**\n * The computed (row, col) position of each tile (the output).\n * @type {?}\n */\nTileCoordinator.prototype.positions;\n}\n\n/**\n * Simple data structure for tile position (row, col).\n * \\@docs-private\n */\nexport class TilePosition {\n/**\n * @param {?} row\n * @param {?} col\n */\nconstructor(public row: number,\npublic col: number) {}\n}\n\nfunction TilePosition_tsickle_Closure_declarations() {\n/** @type {?} */\nTilePosition.prototype.row;\n/** @type {?} */\nTilePosition.prototype.col;\n}\n\n"]}