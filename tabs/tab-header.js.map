{"version":3,"sources":["../../../../src/lib/tabs/tab-header.ts"],"names":[],"mappings":"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","file":"tab-header.js","sourceRoot":"","sourcesContent":["import {\n  ViewChild,\n  Component,\n  Input,\n  QueryList,\n  ElementRef,\n  ViewEncapsulation,\n  ContentChildren,\n  Output,\n  EventEmitter,\n  Optional,\n  AfterContentChecked,\n  AfterContentInit,\n  OnDestroy,\n} from '@angular/core';\nimport {RIGHT_ARROW, LEFT_ARROW, ENTER, Dir, LayoutDirection} from '../core';\nimport {MdTabLabelWrapper} from './tab-label-wrapper';\nimport {MdInkBar} from './ink-bar';\nimport {Subscription} from 'rxjs/Subscription';\nimport {applyCssTransform} from '../core/style/apply-transform';\nimport'rxjs/add/operator/map';\n\n/**\n * The directions that scrolling can go in when the header's tabs exceed the header width. 'After'\n * will scroll the header towards the end of the tabs list and 'before' will scroll towards the\n * beginning of the list.\n */\nexport type ScrollDirection = 'after' | 'before';\n/**\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n */\nconst EXAGGERATED_OVERSCROLL = 60;\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n * \\@docs-private\n */\nexport class MdTabHeader implements AfterContentChecked, AfterContentInit, OnDestroy {\n   _labelWrappers: QueryList<MdTabLabelWrapper>;\n\n   _inkBar: MdInkBar;\n   _tabListContainer: ElementRef;\n   _tabList: ElementRef;\n/**\n * The tab index that is focused.\n */\nprivate _focusIndex: number = 0;\n/**\n * The distance in pixels that the tab labels should be translated to the left.\n */\nprivate _scrollDistance = 0;\n/**\n * Whether the header should scroll to the selected index after the view has been checked.\n */\nprivate _selectedIndexChanged = false;\n/**\n * Subscription to changes in the layout direction.\n */\nprivate _directionChange: Subscription;\n/**\n * Whether the controls for pagination should be displayed\n */\n_showPaginationControls = false;\n/**\n * Whether the tab list can be scrolled more towards the end of the tab label list.\n */\n_disableScrollAfter = true;\n/**\n * Whether the tab list can be scrolled more towards the beginning of the tab label list.\n */\n_disableScrollBefore = true;\n/**\n * The number of tab labels that are displayed on the header. When this changes, the header\n * should re-evaluate the scroll position.\n */\nprivate _tabLabelCount: number;\n/**\n * Whether the scroll distance has changed and should be applied after the view is checked.\n */\nprivate _scrollDistanceChanged: boolean;\nprivate _selectedIndex: number = 0;\n/**\n * The index of the active tab.\n * @param {?} value\n * @return {?}\n */\nset selectedIndex(value: number) {\n    this._selectedIndexChanged = this._selectedIndex != value;\n\n    this._selectedIndex = value;\n    this._focusIndex = value;\n  }\n/**\n * @return {?}\n */\nget selectedIndex(): number { return this._selectedIndex; }\n/**\n * Event emitted when the option is selected.\n */\nselectFocusedIndex = new EventEmitter();\n/**\n * Event emitted when a label is focused.\n */\nindexFocused = new EventEmitter();\n/**\n * @param {?} _elementRef\n * @param {?} _dir\n */\nconstructor(private _elementRef: ElementRef,\nprivate _dir: Dir) {}\n/**\n * @return {?}\n */\nngAfterContentChecked(): void {\n    // If the number of tab labels have changed, check if scrolling should be enabled\n    if (this._tabLabelCount != this._labelWrappers.length) {\n      this._updatePagination();\n      this._tabLabelCount = this._labelWrappers.length;\n    }\n\n    // If the selected index has changed, scroll to the label and check if the scrolling controls\n    // should be disabled.\n    if (this._selectedIndexChanged) {\n      this._scrollToLabel(this._selectedIndex);\n      this._checkScrollingControls();\n      this._alignInkBarToSelectedTab();\n      this._selectedIndexChanged = false;\n    }\n\n    // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n    // then translate the header to reflect this.\n    if (this._scrollDistanceChanged) {\n      this._updateTabScrollPosition();\n      this._scrollDistanceChanged = false;\n    }\n  }\n/**\n * @param {?} event\n * @return {?}\n */\n_handleKeydown(event: KeyboardEvent) {\n    switch (event.keyCode) {\n      case RIGHT_ARROW:\n        this._focusNextTab();\n        break;\n      case LEFT_ARROW:\n        this._focusPreviousTab();\n        break;\n      case ENTER:\n        this.selectFocusedIndex.emit(this.focusIndex);\n        break;\n    }\n  }\n/**\n * Aligns the ink bar to the selected tab on load.\n * @return {?}\n */\nngAfterContentInit() {\n    this._alignInkBarToSelectedTab();\n\n    if (this._dir) {\n      this._directionChange = this._dir.dirChange.subscribe(() => this._alignInkBarToSelectedTab());\n    }\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    if (this._directionChange) {\n      this._directionChange.unsubscribe();\n      this._directionChange = null;\n    }\n  }\n/**\n * Callback for when the MutationObserver detects that the content has changed.\n * @return {?}\n */\n_onContentChanges() {\n    this._updatePagination();\n    this._alignInkBarToSelectedTab();\n  }\n/**\n * Updating the view whether pagination should be enabled or not\n * @return {?}\n */\n_updatePagination() {\n    this._checkPaginationEnabled();\n    this._checkScrollingControls();\n    this._updateTabScrollPosition();\n  }\n/**\n * When the focus index is set, we must manually send focus to the correct label\n * @param {?} value\n * @return {?}\n */\nset focusIndex(value: number) {\n    if (!this._isValidIndex(value) || this._focusIndex == value) { return; }\n\n    this._focusIndex = value;\n    this.indexFocused.emit(value);\n\n    this._setTabFocus(value);\n  }\n/**\n * Tracks which element has focus; used for keyboard navigation\n * @return {?}\n */\nget focusIndex(): number { return this._focusIndex; }\n/**\n * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n * providing a valid index and return true.\n * @param {?} index\n * @return {?}\n */\n_isValidIndex(index: number): boolean {\n    if (!this._labelWrappers) { return true; }\n\n    const /** @type {?} */ tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\n    return tab && !tab.disabled;\n  }\n/**\n * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n * scrolling is enabled.\n * @param {?} tabIndex\n * @return {?}\n */\n_setTabFocus(tabIndex: number) {\n    if (this._showPaginationControls) {\n      this._scrollToLabel(tabIndex);\n    }\n\n    if (this._labelWrappers && this._labelWrappers.length) {\n      this._labelWrappers.toArray()[tabIndex].focus();\n\n      // Do not let the browser manage scrolling to focus the element, this will be handled\n      // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n      // should be the full width minus the offset width.\n      const /** @type {?} */ containerEl = this._tabListContainer.nativeElement;\n      const /** @type {?} */ dir = this._getLayoutDirection();\n      if (dir == 'ltr') {\n        containerEl.scrollLeft = 0;\n      } else {\n        containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n      }\n    }\n  }\n/**\n * Moves the focus towards the beginning or the end of the list depending on the offset provided.\n * Valid offsets are 1 and -1.\n * @param {?} offset\n * @return {?}\n */\n_moveFocus(offset: number) {\n    if (this._labelWrappers) {\n      const /** @type {?} */ tabs: MdTabLabelWrapper[] = this._labelWrappers.toArray();\n      for (let /** @type {?} */ i = this.focusIndex + offset; i < tabs.length && i >= 0; i += offset) {\n        if (this._isValidIndex(i)) {\n          this.focusIndex = i;\n          return;\n        }\n      }\n    }\n  }\n/**\n * Increment the focus index by 1 until a valid tab is found.\n * @return {?}\n */\n_focusNextTab(): void {\n    this._moveFocus(this._getLayoutDirection() == 'ltr' ? 1 : -1);\n  }\n/**\n * Decrement the focus index by 1 until a valid tab is found.\n * @return {?}\n */\n_focusPreviousTab(): void {\n    this._moveFocus(this._getLayoutDirection() == 'ltr' ? -1 : 1);\n  }\n/**\n * The layout direction of the containing app.\n * @return {?}\n */\n_getLayoutDirection(): LayoutDirection {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n/**\n * Performs the CSS transformation on the tab list that will cause the list to scroll.\n * @return {?}\n */\n_updateTabScrollPosition() {\n    let /** @type {?} */ translateX = this.scrollDistance + 'px';\n    if (this._getLayoutDirection() == 'ltr') {\n      translateX = '-' + translateX;\n    }\n\n    applyCssTransform(this._tabList.nativeElement, `translate3d(${translateX}, 0, 0)`);\n  }\n/**\n * Sets the distance in pixels that the tab header should be transformed in the X-axis.\n * @param {?} v\n * @return {?}\n */\nset scrollDistance(v: number) {\n    this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v));\n\n    // Mark that the scroll distance has changed so that after the view is checked, the CSS\n    // transformation can move the header.\n    this._scrollDistanceChanged = true;\n\n    this._checkScrollingControls();\n  }\n/**\n * @return {?}\n */\nget scrollDistance(): number { return this._scrollDistance;  }\n/**\n * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n * the end of the list, respectively). The distance to scroll is computed to be a third of the\n * length of the tab list view window.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @param {?} scrollDir\n * @return {?}\n */\n_scrollHeader(scrollDir: ScrollDirection) {\n    const /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\n\n    // Move the scroll distance one-third the length of the tab list's viewport.\n    this.scrollDistance += (scrollDir == 'before' ? -1 : 1) * viewLength / 3;\n  }\n/**\n * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @param {?} labelIndex\n * @return {?}\n */\n_scrollToLabel(labelIndex: number) {\n    const /** @type {?} */ selectedLabel = this._labelWrappers\n        ? this._labelWrappers.toArray()[labelIndex]\n        :  null;\n\n    if (!selectedLabel) { return; }\n\n    // The view length is the visible width of the tab labels.\n    const /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\n\n    let /** @type {?} */ labelBeforePos: number, /** @type {?} */ labelAfterPos: number;\n    if (this._getLayoutDirection() == 'ltr') {\n      labelBeforePos = selectedLabel.getOffsetLeft();\n      labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\n    } else {\n      labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\n      labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\n    }\n\n    const /** @type {?} */ beforeVisiblePos = this.scrollDistance;\n    const /** @type {?} */ afterVisiblePos = this.scrollDistance + viewLength;\n\n    if (labelBeforePos < beforeVisiblePos) {\n      // Scroll header to move label to the before direction\n      this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n    } else if (labelAfterPos > afterVisiblePos) {\n      // Scroll header to move label to the after direction\n      this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n    }\n  }\n/**\n * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n * tab list is wider than the size of the header container, then the pagination controls should\n * be shown.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @return {?}\n */\n_checkPaginationEnabled() {\n    this._showPaginationControls =\n        this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n\n    if (!this._showPaginationControls) {\n      this.scrollDistance = 0;\n    }\n  }\n/**\n * Evaluate whether the before and after controls should be enabled or disabled.\n * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n * before button. If the header is at the end of the list (scroll distance is equal to the\n * maximum distance we can scroll), then disable the after button.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @return {?}\n */\n_checkScrollingControls() {\n    // Check if the pagination arrows should be activated.\n    this._disableScrollBefore = this.scrollDistance == 0;\n    this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n  }\n/**\n * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n * is equal to the difference in width between the tab list container and tab header container.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @return {?}\n */\n_getMaxScrollDistance(): number {\n    const /** @type {?} */ lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n    const /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\n    return lengthOfTabList - viewLength;\n  }\n/**\n * Tells the ink-bar to align itself to the current label wrapper\n * @return {?}\n */\nprivate _alignInkBarToSelectedTab(): void {\n    const /** @type {?} */ selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length\n        ? this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement\n        : null;\n\n    this._inkBar.alignToElement(selectedLabelWrapper);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'md-tab-header, mat-tab-header',\n  templateUrl: 'tab-header.html',\n  styleUrls: ['tab-header.css'],\n  encapsulation: ViewEncapsulation.None,\n  host: {\n    'class': 'mat-tab-header',\n    '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',\n    '[class.mat-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\",\n  }\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: Dir, decorators: [{ type: Optional }, ]},\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'_labelWrappers': [{ type: ContentChildren, args: [MdTabLabelWrapper, ] },],\n'_inkBar': [{ type: ViewChild, args: [MdInkBar, ] },],\n'_tabListContainer': [{ type: ViewChild, args: ['tabListContainer', ] },],\n'_tabList': [{ type: ViewChild, args: ['tabList', ] },],\n'selectedIndex': [{ type: Input },],\n'selectFocusedIndex': [{ type: Output },],\n'indexFocused': [{ type: Output },],\n};\n}\n\nfunction MdTabHeader_tsickle_Closure_declarations() {\n/** @type {?} */\nMdTabHeader.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMdTabHeader.ctorParameters;\n/** @type {?} */\nMdTabHeader.propDecorators;\n/** @type {?} */\nMdTabHeader.prototype._labelWrappers;\n/** @type {?} */\nMdTabHeader.prototype._inkBar;\n/** @type {?} */\nMdTabHeader.prototype._tabListContainer;\n/** @type {?} */\nMdTabHeader.prototype._tabList;\n/**\n * The tab index that is focused.\n * @type {?}\n */\nMdTabHeader.prototype._focusIndex;\n/**\n * The distance in pixels that the tab labels should be translated to the left.\n * @type {?}\n */\nMdTabHeader.prototype._scrollDistance;\n/**\n * Whether the header should scroll to the selected index after the view has been checked.\n * @type {?}\n */\nMdTabHeader.prototype._selectedIndexChanged;\n/**\n * Subscription to changes in the layout direction.\n * @type {?}\n */\nMdTabHeader.prototype._directionChange;\n/**\n * Whether the controls for pagination should be displayed\n * @type {?}\n */\nMdTabHeader.prototype._showPaginationControls;\n/**\n * Whether the tab list can be scrolled more towards the end of the tab label list.\n * @type {?}\n */\nMdTabHeader.prototype._disableScrollAfter;\n/**\n * Whether the tab list can be scrolled more towards the beginning of the tab label list.\n * @type {?}\n */\nMdTabHeader.prototype._disableScrollBefore;\n/**\n * The number of tab labels that are displayed on the header. When this changes, the header\n * should re-evaluate the scroll position.\n * @type {?}\n */\nMdTabHeader.prototype._tabLabelCount;\n/**\n * Whether the scroll distance has changed and should be applied after the view is checked.\n * @type {?}\n */\nMdTabHeader.prototype._scrollDistanceChanged;\n/** @type {?} */\nMdTabHeader.prototype._selectedIndex;\n/**\n * Event emitted when the option is selected.\n * @type {?}\n */\nMdTabHeader.prototype.selectFocusedIndex;\n/**\n * Event emitted when a label is focused.\n * @type {?}\n */\nMdTabHeader.prototype.indexFocused;\n/** @type {?} */\nMdTabHeader.prototype._elementRef;\n/** @type {?} */\nMdTabHeader.prototype._dir;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}