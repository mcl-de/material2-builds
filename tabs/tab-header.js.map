{"version":3,"sources":["../../../../src/lib/tabs/tab-header.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,SAAS,EACT,SAAS,EACT,KAAK,EAEL,UAAU,EACV,iBAAiB,EACjB,eAAe,EACf,MAAM,EACN,YAAY,EACZ,QAAQ,GAIT,MAAM,eAAA,CAAgB;AACvB,OAAO,EAAA,WAAE,EAAY,UAAA,EAAY,KAAA,EAAO,GAAA,EAAqB,MAAA,SAAA,CAAA;AAC7D,OAAO,EAAA,iBAAE,EAAiB,MAAA,qBAAA,CAAA;AAC1B,OAAO,EAAA,QAAE,EAAQ,MAAA,WAAA,CAAA;AAEjB,OAAO,EAAA,iBAAE,EAAiB,MAAA,+BAAA,CAAA;AAC1B,OAAM,uBAAC,CAAA;AASP;;;GAGG;AACH,MAAM,gBAAA,CAAA,sBAAA,GAAyB,EAAA,CAAG;AAClC;;;;;;GAMG;AACH,MAEC;IAyCD;;;OAGG;IACH,YASsB,WAAa,EAAqB,IAAM;QAAxC,gBAAA,GAAA,WAAA,CAAa;QAAqB,SAAA,GAAA,IAAA,CAAM;QA9CpD,gBAAA,GAAsB,CAAA,CAAE;QAGxB,oBAAA,GAAkB,CAAA,CAAE;QAGpB,0BAAA,GAAwB,KAAA,CAAM;QALtC,8DAA8D;QAC9D,4BAAuB,GAUG,KAAA,CAAM;QARhC,uFAAuF;QACvF,wBAAmB,GAUG,IAAA,CAAK;QAR3B,6FAA6F;QAC7F,yBAAoB,GAUG,IAAA,CAAK;QAWpB,mBAAA,GAAyB,CAAA,CAAE;QADnC,iDAAiD;QAChD,uBAAkB,GAYG,IAAI,YAAA,EAAa,CAAE;QAVzC,6CAA6C;QAC5C,iBAAY,GAYG,IAAI,YAAA,EAAa,CAAE;IAE6B,CAAA;IAlClE;;;;OAIG;IACH,IAeI,aAAA,CAAA,KAAA;QAdA,IAAI,CAeC,qBAAC,GAAuB,IAAA,CAAK,cAAC,IAAiB,KAAA,CAAM;QAb1D,IAAI,CAeC,cAAC,GAAgB,KAAA,CAAM;QAd5B,IAAI,CAeC,WAAC,GAAa,KAAA,CAAM;IAd3B,CAAC;IACH;;OAEG;IACH,IAYG,aAAA,KAA6B,MAAA,CAAO,IAAA,CAAK,cAAC,CAAc,CAAC,CAAA;IAC5D;;OAEG;IACH,qBAMG;QALC,iFAAiF;QACjF,EAAE,CAAC,CAAC,IAMC,CAAI,cAAC,IAAiB,IAAA,CAAK,cAAC,CAAc,MAAC,CAAM,CAAC,CAAA;YALrD,IAAI,CAMC,iBAAC,EAAiB,CAAE;YALzB,IAAI,CAMC,cAAC,GAAgB,IAAA,CAAK,cAAC,CAAc,MAAC,CAAM;QALnD,CAAC;QAED,6FAA6F;QAC7F,sBAAsB;QACtB,EAAE,CAAC,CAAC,IAMC,CAAI,qBAAC,CAAqB,CAAC,CAAA;YAL9B,IAAI,CAMC,cAAC,CAAc,IAAC,CAAI,cAAC,CAAc,CAAC;YALzC,IAAI,CAMC,uBAAC,EAAuB,CAAE;YAL/B,IAAI,CAMC,yBAAC,EAAyB,CAAE;YALjC,IAAI,CAMC,qBAAC,GAAuB,KAAA,CAAM;QALrC,CAAC;QAED,8FAA8F;QAC9F,6CAA6C;QAC7C,EAAE,CAAC,CAAC,IAMC,CAAI,sBAAC,CAAsB,CAAC,CAAA;YAL/B,IAAI,CAMC,wBAAC,EAAwB,CAAE;YALhC,IAAI,CAMC,sBAAC,GAAwB,KAAA,CAAM;QALtC,CAAC;IACH,CAAC;IACH;;;OAGG;IACH,cAGG,CAAA,KAAA;QAFC,MAAM,CAAC,CAAC,KAGC,CAAK,OAAC,CAAO,CAAC,CAAA;YAFrB,KAGK,WAAA;gBAFH,IAAI,CAGC,aAAC,EAAa,CAAE;gBAFrB,KAAK,CAAC;YACR,KAGK,UAAA;gBAFH,IAAI,CAGC,iBAAC,EAAiB,CAAE;gBAFzB,KAAK,CAAC;YACR,KAGK,KAAA;gBAFH,IAAI,CAGC,kBAAC,CAAkB,IAAC,CAAI,IAAC,CAAI,UAAC,CAAU,CAAC;gBAF9C,KAAK,CAAC;QACV,CAAC;IACH,CAAC;IACH;;;OAGG;IACH,kBAGG;QAFC,IAAI,CAGC,yBAAC,EAAyB,CAAE;QADjC,EAAE,CAAC,CAAC,IAGC,CAAI,IAAC,CAAI,CAAC,CAAA;YAFb,IAAI,CAGC,gBAAC,GAAkB,IAAA,CAAK,IAAC,CAAI,SAAC,CAAS,SAAC,CAAS,MAAM,IAAA,CAAK,yBAAC,EAAyB,CAAE,CAAC;QAFhG,CAAC;IACH,CAAC;IACH;;OAEG;IACH,WACG;QAAC,EAAE,CAAC,CAAC,IACC,CAAI,gBAAC,CAAgB,CAAC,CAAA;YAAzB,IAAI,CACC,gBAAC,CAAgB,WAAC,EAAW,CAAE;YAApC,IAAI,CACC,gBAAC,GAAkB,IAAA,CAAK;QAA/B,CAAC;IACH,CAAC;IACH;;;OAGG;IACH,iBACG;QAAC,IAAI,CACC,iBAAC,EAAiB,CAAE;QAAzB,IAAI,CACC,yBAAC,EAAyB,CAAE;IAAnC,CAAC;IACH;;;OAGG;IACH,iBACG;QAAC,IAAI,CACC,uBAAC,EAAuB,CAAE;QAA/B,IAAI,CACC,uBAAC,EAAuB,CAAE;QAA/B,IAAI,CACC,wBAAC,EAAwB,CAAE;IAAlC,CAAC;IACH;;;;OAIG;IACH,IAFG,UAAA,CAAA,KAAA;QAGC,EAAE,CAAC,CAAC,CAFC,IAAC,CAAI,aAAC,CAAa,KAAC,CAAK,IAAI,IAAA,CAAK,WAAC,IAAc,KAAA,CAAM,CAAC,CAAA;YAAE,MAAA,CAAA;QAAQ,CAAA;QAIvE,IAAI,CAFC,WAAC,GAAa,KAAA,CAAM;QAGzB,IAAI,CAFC,YAAC,CAAY,IAAC,CAAI,KAAC,CAAK,CAAC;QAI9B,IAAI,CAFC,YAAC,CAAY,KAAC,CAAK,CAAC;IAG3B,CAAC;IACH;;;OAGG;IACH,IAJG,UAAA,KAA0B,MAAA,CAAO,IAAA,CAAK,WAAC,CAAW,CAAC,CAAA;IAKtD;;;;;OAKG;IACH,aALG,CAAA,KAAA;QAMC,EAAE,CAAC,CAAC,CALC,IAAC,CAAI,cAAC,CAAc,CAAC,CAAA;YAAE,MAAA,CAAO,IAAA,CAAK;QAAC,CAAA;QAOzC,MAAM,gBAAgB,CALhB,GAAA,GAAM,IAAA,CAAK,cAAC,GAAgB,IAAA,CAAK,cAAC,CAAc,OAAC,EAAO,CAAE,KAAC,CAAK,GAAG,IAAA,CAAK;QAM9E,MAAM,CALC,GAAA,IAAO,CAAA,GAAE,CAAG,QAAC,CAAQ;IAM9B,CAAC;IACH;;;;;OAKG;IACH,YANG,CAAA,QAAA;QAOC,EAAE,CAAC,CAAC,IANC,CAAI,uBAAC,CAAuB,CAAC,CAAA;YAOhC,IAAI,CANC,cAAC,CAAc,QAAC,CAAQ,CAAC;QAOhC,CAAC;QAED,EAAE,CAAC,CAAC,IANC,CAAI,cAAC,IAAiB,IAAA,CAAK,cAAC,CAAc,MAAC,CAAM,CAAC,CAAA;YAOrD,IAAI,CANC,cAAC,CAAc,OAAC,EAAO,CAAE,QAAC,CAAQ,CAAC,KAAC,EAAK,CAAE;YAQhD,qFAAqF;YACrF,sFAAsF;YACtF,mDAAmD;YACnD,MAAM,gBAAgB,CANhB,WAAA,GAAc,IAAA,CAAK,iBAAC,CAAiB,aAAC,CAAa;YAOzD,MAAM,gBAAgB,CANhB,GAAA,GAAM,IAAA,CAAK,mBAAC,EAAmB,CAAE;YAOvC,EAAE,CAAC,CAAC,GANC,IAAM,KAAA,CAAM,CAAC,CAAA;gBAOhB,WAAW,CANC,UAAC,GAAY,CAAA,CAAE;YAO7B,CAAC;YANC,IAAA,CAAK,CAAA;gBAOL,WAAW,CANC,UAAC,GAAY,WAAA,CAAY,WAAC,GAAa,WAAA,CAAY,WAAC,CAAW;YAO7E,CAAC;QACH,CAAC;IACH,CAAC;IACH;;;;;OAKG;IACH,UAPG,CAAA,MAAA;QAQC,EAAE,CAAC,CAAC,IAPC,CAAI,cAAC,CAAc,CAAC,CAAA;YAQvB,MAAM,gBAAgB,CAPhB,IAAA,GAA4B,IAAA,CAAK,cAAC,CAAc,OAAC,EAAO,CAAE;YAQhE,GAAG,CAAC,CAAC,IAPC,gBAAA,CAAG,CAAA,GAAI,IAAA,CAAK,UAAC,GAAY,MAAA,EAAQ,CAAA,GAAI,IAAA,CAAK,MAAC,IAAS,CAAA,IAAK,CAAA,EAAG,CAAA,IAAK,MAAA,EAAQ,CAAA;gBAQ7E,EAAE,CAAC,CAAC,IAPC,CAAI,aAAC,CAAa,CAAC,CAAC,CAAC,CAAC,CAAA;oBAQzB,IAAI,CAPC,UAAC,GAAY,CAAA,CAAE;oBAQpB,MAAM,CAAC;gBACT,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IACH;;;OAGG;IACH,aATG;QAUC,IAAI,CATC,UAAC,CAAU,IAAC,CAAI,mBAAC,EAAmB,IAAK,KAAA,GAAQ,CAAA,GAAI,CAAA,CAAE,CAAC,CAAC;IAUhE,CAAC;IACH;;;OAGG;IACH,iBAXG;QAYC,IAAI,CAXC,UAAC,CAAU,IAAC,CAAI,mBAAC,EAAmB,IAAK,KAAA,GAAQ,CAAA,CAAE,GAAG,CAAA,CAAE,CAAC;IAYhE,CAAC;IACH;;;OAGG;IACH,mBAbG;QAcC,MAAM,CAbC,IAAA,CAAK,IAAC,IAAO,IAAA,CAAK,IAAC,CAAI,KAAC,KAAS,KAAA,GAAQ,KAAA,GAAQ,KAAA,CAAM;IAchE,CAAC;IACH;;;OAGG;IACH,wBAfG;QAgBC,IAAI,gBAAgB,CAfhB,UAAA,GAAa,IAAA,CAAK,cAAC,GAAgB,IAAA,CAAK;QAgB5C,EAAE,CAAC,CAAC,IAfC,CAAI,mBAAC,EAAmB,IAAK,KAAA,CAAM,CAAC,CAAA;YAgBvC,UAAU,GAfG,GAAA,GAAM,UAAA,CAAW;QAgBhC,CAAC;QAED,iBAAiB,CAfC,IAAC,CAAI,QAAC,CAAQ,aAAC,EAAc,eAAA,UAAgB,SAAU,CAAS,CAAC;IAgBrF,CAAC;IACH;;;;OAIG;IACH,IAlBG,cAAA,CAAA,CAAA;QAmBC,IAAI,CAlBC,eAAC,GAAiB,IAAA,CAAK,GAAC,CAAG,CAAC,EAAE,IAAA,CAAK,GAAC,CAAG,IAAC,CAAI,qBAAC,EAAqB,EAAG,CAAA,CAAE,CAAC,CAAC;QAoB9E,uFAAuF;QACvF,sCAAsC;QACtC,IAAI,CAlBC,sBAAC,GAAwB,IAAA,CAAK;QAoBnC,IAAI,CAlBC,uBAAC,EAAuB,CAAE;IAmBjC,CAAC;IACH;;OAEG;IACH,IArBG,cAAA,KAA8B,MAAA,CAAO,IAAA,CAAK,eAAC,CAAe,CAAC,CAAA;IAsB9D;;;;;;;;;OASG;IACH,aAtBG,CAAA,SAAA;QAuBC,MAAM,gBAAgB,CAtBhB,UAAA,GAAa,IAAA,CAAK,iBAAC,CAAiB,aAAC,CAAa,WAAC,CAAW;QAwBpE,4EAA4E;QAC5E,IAAI,CAtBC,cAAC,IAAiB,CAAA,SAAE,IAAY,QAAA,GAAW,CAAA,CAAE,GAAG,CAAA,CAAE,GAAG,UAAA,GAAa,CAAA,CAAE;IAuB3E,CAAC;IACH;;;;;;;OAOG;IACH,cAvBG,CAAA,UAAA;QAwBC,MAAM,gBAAgB,CAvBhB,aAAA,GAAgB,IAAA,CAAK,cAAC;cACtB,IAAA,CAAK,cAAC,CAAc,OAAC,EAAO,CAAE,UAAC,CAAU;cACzC,IAAA,CAAM;QAyBZ,EAAE,CAAC,CAAC,CAvBC,aAAC,CAAa,CAAC,CAAA;YAAE,MAAA,CAAA;QAAQ,CAAA;QAyB9B,0DAA0D;QAC1D,MAAM,gBAAgB,CAvBhB,UAAA,GAAa,IAAA,CAAK,iBAAC,CAAiB,aAAC,CAAa,WAAC,CAAW;QAyBpE,IAAI,gBAAgB,CAvBhB,cAAgB,EAAO,gBAAA,CAAC,aAAe,CAAO;QAwBlD,EAAE,CAAC,CAAC,IAvBC,CAAI,mBAAC,EAAmB,IAAK,KAAA,CAAM,CAAC,CAAA;YAwBvC,cAAc,GAvBG,aAAA,CAAc,aAAC,EAAa,CAAE;YAwB/C,aAAa,GAvBG,cAAA,GAAiB,aAAA,CAAc,cAAC,EAAc,CAAE;QAwBlE,CAAC;QAvBC,IAAA,CAAK,CAAA;YAwBL,aAAa,GAvBG,IAAA,CAAK,QAAC,CAAQ,aAAC,CAAa,WAAC,GAAa,aAAA,CAAc,aAAC,EAAa,CAAE;YAwBxF,cAAc,GAvBG,aAAA,GAAgB,aAAA,CAAc,cAAC,EAAc,CAAE;QAwBlE,CAAC;QAED,MAAM,gBAAgB,CAvBhB,gBAAA,GAAmB,IAAA,CAAK,cAAC,CAAc;QAwB7C,MAAM,gBAAgB,CAvBhB,eAAA,GAAkB,IAAA,CAAK,cAAC,GAAgB,UAAA,CAAW;QAyBzD,EAAE,CAAC,CAAC,cAvBC,GAAgB,gBAAA,CAAiB,CAAC,CAAA;YAwBrC,sDAAsD;YACtD,IAAI,CAvBC,cAAC,IAAiB,gBAAA,GAAmB,cAAA,GAAiB,sBAAA,CAAuB;QAwBpF,CAAC;QAvBC,IAAA,CAAK,EAAA,CAAA,CAAA,aAAK,GAAe,eAAA,CAAgB,CAAC,CAAA;YAwB1C,qDAAqD;YACrD,IAAI,CAvBC,cAAC,IAAiB,aAAA,GAAgB,eAAA,GAAkB,sBAAA,CAAuB;QAwBlF,CAAC;IACH,CAAC;IACH;;;;;;;;OAQG;IACH,uBAvBG;QAwBC,IAAI,CAvBC,uBAAC;YAwBF,IAAI,CAvBC,QAAC,CAAQ,aAAC,CAAa,WAAC,GAAa,IAAA,CAAK,WAAC,CAAW,aAAC,CAAa,WAAC,CAAW;QAyBzF,EAAE,CAAC,CAAC,CAvBC,IAAC,CAAI,uBAAC,CAAuB,CAAC,CAAA;YAwBjC,IAAI,CAvBC,cAAC,GAAgB,CAAA,CAAE;QAwB1B,CAAC;IACH,CAAC;IACH;;;;;;;;;OASG;IACH,uBAvBG;QAwBC,sDAAsD;QACtD,IAAI,CAvBC,oBAAC,GAAsB,IAAA,CAAK,cAAC,IAAiB,CAAA,CAAE;QAwBrD,IAAI,CAvBC,mBAAC,GAAqB,IAAA,CAAK,cAAC,IAAiB,IAAA,CAAK,qBAAC,EAAqB,CAAE;IAwBjF,CAAC;IACH;;;;;;;OAOG;IACH,qBAvBG;QAwBC,MAAM,gBAAgB,CAvBhB,eAAA,GAAkB,IAAA,CAAK,QAAC,CAAQ,aAAC,CAAa,WAAC,CAAW;QAwBhE,MAAM,gBAAgB,CAvBhB,UAAA,GAAa,IAAA,CAAK,iBAAC,CAAiB,aAAC,CAAa,WAAC,CAAW;QAwBpE,MAAM,CAvBC,eAAA,GAAkB,UAAA,CAAW;IAwBtC,CAAC;IACH;;;OAGG;IAxBA,yBAAA;QA0BC,MAAM,gBAAgB,CAzBhB,oBAAA,GAAuB,IAAA,CAAK,cAAC,IAAiB,IAAA,CAAK,cAAC,CAAc,MAAC;cACnE,IAAA,CAAK,cAAC,CAAc,OAAC,EAAO,CAAE,IAAC,CAAI,aAAC,CAAa,CAAC,UAAC,CAAU,aAAC;cAC9D,IAAA,CAAK;QA2BX,IAAI,CAzBC,OAAC,CAAO,cAAC,CAAc,oBAAC,CAAoB,CAAC;IA0BpD,CAAC;;AAxBI,sBAAA,GAAoC;IA0B3C,EAzBE,IAAA,EAAM,SAAA,EAAW,IAAA,EAAM,CAAA;gBA0BvB,QAAQ,EAzBE,MAAA,CAAO,EAAC;gBASlB,QAAA,EARU,+BAAA;gBA0BV,WAAW,EAzBE,iBAAA;gBA0Bb,SAAS,EAzBE,CAAA,gBAAE,CAAgB;gBA0B7B,aAAa,EAzBE,iBAAA,CAAkB,IAAC;gBA0BlC,IAAI,EAzBE;oBA0BJ,OAAO,EAzBE,gBAAA;oBA0BT,oDAAoD,EAzBE,yBAAA;oBA0BtD,4BAA4B,EAzBE,gCAAA;iBA0B/B;aACF,EAzBC,EAAG;CA0BJ,CAzBC;AA0BF;;GAEG;AA1BF,0BAAA,GAAA,MAAA;IA4BD,EAAC,IAAI,EAAE,UAAU,GAAG;IACpB,EAAC,IAAI,EAAE,GAAG,EAAE,UAAU,EAAE,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,EAAG,EAAC;CAC9C,CAAC;AA1BK,0BAAA,GAAyD;IA4BhE,gBAAgB,EA3BE,CAAA,EAAG,IAAA,EAAM,eAAA,EAAiB,IAAA,EAAM,CAAA,iBAAE,EAAiB,EAAG,EAAE;IA4B1E,SAAS,EA3BE,CAAA,EAAG,IAAA,EAAM,SAAA,EAAW,IAAA,EAAM,CAAA,QAAE,EAAQ,EAAG,EAAE;IA4BpD,mBAAmB,EA3BE,CAAA,EAAG,IAAA,EAAM,SAAA,EAAW,IAAA,EAAM,CAAA,kBAAE,EAAkB,EAAG,EAAE;IA4BxE,UAAU,EA3BE,CAAA,EAAG,IAAA,EAAM,SAAA,EAAW,IAAA,EAAM,CAAA,SAAE,EAAS,EAAG,EAAE;IA4BtD,eAAe,EA3BE,CAAA,EAAG,IAAA,EAAM,KAAA,EAAM,EAAE;IA4BlC,oBAAoB,EA3BE,CAAA,EAAG,IAAA,EAAM,MAAA,EAAO,EAAE;IA4BxC,cAAc,EA3BE,CAAA,EAAG,IAAA,EAAM,MAAA,EAAO,EAAE;CA4BjC,CA3BC;AA8BF;IACA,gBAAgB;IAChB,WAAW,CAAC,UAAU,CAAC;IACvB;;;OAGG;IACH,WAAW,CAAC,cAAc,CAAC;IAC3B,gBAAgB;IAChB,WAAW,CAAC,cAAc,CAAC;IAC3B,gBAAgB;IAChB,WAAW,CAAC,SAAS,CAAC,cAAc,CAAC;IACrC,gBAAgB;IAChB,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC;IAC9B,gBAAgB;IAChB,WAAW,CAAC,SAAS,CAAC,iBAAiB,CAAC;IACxC,gBAAgB;IAChB,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC;IAC/B;;;OAGG;IACH,WAAW,CAAC,SAAS,CAAC,WAAW,CAAC;IAClC;;;OAGG;IACH,WAAW,CAAC,SAAS,CAAC,eAAe,CAAC;IACtC;;;OAGG;IACH,WAAW,CAAC,SAAS,CAAC,qBAAqB,CAAC;IAC5C;;;OAGG;IACH,WAAW,CAAC,SAAS,CAAC,gBAAgB,CAAC;IACvC;;;OAGG;IACH,WAAW,CAAC,SAAS,CAAC,uBAAuB,CAAC;IAC9C;;;OAGG;IACH,WAAW,CAAC,SAAS,CAAC,mBAAmB,CAAC;IAC1C;;;OAGG;IACH,WAAW,CAAC,SAAS,CAAC,oBAAoB,CAAC;IAC3C;;;;OAIG;IACH,WAAW,CAAC,SAAS,CAAC,cAAc,CAAC;IACrC;;;OAGG;IACH,WAAW,CAAC,SAAS,CAAC,sBAAsB,CAAC;IAC7C,gBAAgB;IAChB,WAAW,CAAC,SAAS,CAAC,cAAc,CAAC;IACrC;;;OAGG;IACH,WAAW,CAAC,SAAS,CAAC,kBAAkB,CAAC;IACzC;;;OAGG;IACH,WAAW,CAAC,SAAS,CAAC,YAAY,CAAC;IACnC,gBAAgB;IAChB,WAAW,CAAC,SAAS,CAAC,WAAW,CAAC;IAClC,gBAAgB;IAChB,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC;AAC3B,CAAC","file":"tab-header.js","sourceRoot":"","sourcesContent":["import {\n  ViewChild,\n  Component,\n  Input,\n  QueryList,\n  ElementRef,\n  ViewEncapsulation,\n  ContentChildren,\n  Output,\n  EventEmitter,\n  Optional,\n  AfterContentChecked,\n  AfterContentInit,\n  OnDestroy,\n} from '@angular/core';\nimport {RIGHT_ARROW, LEFT_ARROW, ENTER, Dir, LayoutDirection} from '../core';\nimport {MdTabLabelWrapper} from './tab-label-wrapper';\nimport {MdInkBar} from './ink-bar';\nimport {Subscription} from 'rxjs/Subscription';\nimport {applyCssTransform} from '../core/style/apply-transform';\nimport'rxjs/add/operator/map';\n\n/**\n * The directions that scrolling can go in when the header's tabs exceed the header width. 'After'\n * will scroll the header towards the end of the tabs list and 'before' will scroll towards the\n * beginning of the list.\n */\nexport type ScrollDirection = 'after' | 'before';\n\n/**\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n */\nconst /** @type {?} */ EXAGGERATED_OVERSCROLL = 60;\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n * \\@docs-private\n */\nexport class MdTabHeader implements AfterContentChecked, AfterContentInit, OnDestroy {\n   _labelWrappers: QueryList<MdTabLabelWrapper>;\n\n   _inkBar: MdInkBar;\n   _tabListContainer: ElementRef;\n   _tabList: ElementRef;\nprivate _focusIndex: number = 0;\nprivate _scrollDistance = 0;\nprivate _selectedIndexChanged = false;\nprivate _directionChange: Subscription;\n\n  /** Whether the controls for pagination should be displayed */\n  _showPaginationControls = false;\n\n  /** Whether the tab list can be scrolled more towards the end of the tab label list. */\n  _disableScrollAfter = true;\n\n  /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\n  _disableScrollBefore = true;\nprivate _tabLabelCount: number;\nprivate _scrollDistanceChanged: boolean;\nprivate _selectedIndex: number = 0;\n/**\n * The index of the active tab.\n * @param {?} value\n * @return {?}\n */\nset selectedIndex(value: number) {\n    this._selectedIndexChanged = this._selectedIndex != value;\n\n    this._selectedIndex = value;\n    this._focusIndex = value;\n  }\n/**\n * @return {?}\n */\nget selectedIndex(): number { return this._selectedIndex; }\n\n  /** Event emitted when the option is selected. */\n   selectFocusedIndex = new EventEmitter();\n\n  /** Event emitted when a label is focused. */\n   indexFocused = new EventEmitter();\n/**\n * @param {?} _elementRef\n * @param {?} _dir\n */\nconstructor(private _elementRef: ElementRef,\nprivate _dir: Dir) {}\n/**\n * @return {?}\n */\nngAfterContentChecked(): void {\n    // If the number of tab labels have changed, check if scrolling should be enabled\n    if (this._tabLabelCount != this._labelWrappers.length) {\n      this._updatePagination();\n      this._tabLabelCount = this._labelWrappers.length;\n    }\n\n    // If the selected index has changed, scroll to the label and check if the scrolling controls\n    // should be disabled.\n    if (this._selectedIndexChanged) {\n      this._scrollToLabel(this._selectedIndex);\n      this._checkScrollingControls();\n      this._alignInkBarToSelectedTab();\n      this._selectedIndexChanged = false;\n    }\n\n    // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n    // then translate the header to reflect this.\n    if (this._scrollDistanceChanged) {\n      this._updateTabScrollPosition();\n      this._scrollDistanceChanged = false;\n    }\n  }\n/**\n * @param {?} event\n * @return {?}\n */\n_handleKeydown(event: KeyboardEvent) {\n    switch (event.keyCode) {\n      case RIGHT_ARROW:\n        this._focusNextTab();\n        break;\n      case LEFT_ARROW:\n        this._focusPreviousTab();\n        break;\n      case ENTER:\n        this.selectFocusedIndex.emit(this.focusIndex);\n        break;\n    }\n  }\n/**\n * Aligns the ink bar to the selected tab on load.\n * @return {?}\n */\nngAfterContentInit() {\n    this._alignInkBarToSelectedTab();\n\n    if (this._dir) {\n      this._directionChange = this._dir.dirChange.subscribe(() => this._alignInkBarToSelectedTab());\n    }\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    if (this._directionChange) {\n      this._directionChange.unsubscribe();\n      this._directionChange = null;\n    }\n  }\n/**\n * Callback for when the MutationObserver detects that the content has changed.\n * @return {?}\n */\n_onContentChanges() {\n    this._updatePagination();\n    this._alignInkBarToSelectedTab();\n  }\n/**\n * Updating the view whether pagination should be enabled or not\n * @return {?}\n */\n_updatePagination() {\n    this._checkPaginationEnabled();\n    this._checkScrollingControls();\n    this._updateTabScrollPosition();\n  }\n/**\n * When the focus index is set, we must manually send focus to the correct label\n * @param {?} value\n * @return {?}\n */\nset focusIndex(value: number) {\n    if (!this._isValidIndex(value) || this._focusIndex == value) { return; }\n\n    this._focusIndex = value;\n    this.indexFocused.emit(value);\n\n    this._setTabFocus(value);\n  }\n/**\n * Tracks which element has focus; used for keyboard navigation\n * @return {?}\n */\nget focusIndex(): number { return this._focusIndex; }\n/**\n * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n * providing a valid index and return true.\n * @param {?} index\n * @return {?}\n */\n_isValidIndex(index: number): boolean {\n    if (!this._labelWrappers) { return true; }\n\n    const /** @type {?} */ tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\n    return tab && !tab.disabled;\n  }\n/**\n * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n * scrolling is enabled.\n * @param {?} tabIndex\n * @return {?}\n */\n_setTabFocus(tabIndex: number) {\n    if (this._showPaginationControls) {\n      this._scrollToLabel(tabIndex);\n    }\n\n    if (this._labelWrappers && this._labelWrappers.length) {\n      this._labelWrappers.toArray()[tabIndex].focus();\n\n      // Do not let the browser manage scrolling to focus the element, this will be handled\n      // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n      // should be the full width minus the offset width.\n      const /** @type {?} */ containerEl = this._tabListContainer.nativeElement;\n      const /** @type {?} */ dir = this._getLayoutDirection();\n      if (dir == 'ltr') {\n        containerEl.scrollLeft = 0;\n      } else {\n        containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n      }\n    }\n  }\n/**\n * Moves the focus towards the beginning or the end of the list depending on the offset provided.\n * Valid offsets are 1 and -1.\n * @param {?} offset\n * @return {?}\n */\n_moveFocus(offset: number) {\n    if (this._labelWrappers) {\n      const /** @type {?} */ tabs: MdTabLabelWrapper[] = this._labelWrappers.toArray();\n      for (let /** @type {?} */ i = this.focusIndex + offset; i < tabs.length && i >= 0; i += offset) {\n        if (this._isValidIndex(i)) {\n          this.focusIndex = i;\n          return;\n        }\n      }\n    }\n  }\n/**\n * Increment the focus index by 1 until a valid tab is found.\n * @return {?}\n */\n_focusNextTab(): void {\n    this._moveFocus(this._getLayoutDirection() == 'ltr' ? 1 : -1);\n  }\n/**\n * Decrement the focus index by 1 until a valid tab is found.\n * @return {?}\n */\n_focusPreviousTab(): void {\n    this._moveFocus(this._getLayoutDirection() == 'ltr' ? -1 : 1);\n  }\n/**\n * The layout direction of the containing app.\n * @return {?}\n */\n_getLayoutDirection(): LayoutDirection {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n/**\n * Performs the CSS transformation on the tab list that will cause the list to scroll.\n * @return {?}\n */\n_updateTabScrollPosition() {\n    let /** @type {?} */ translateX = this.scrollDistance + 'px';\n    if (this._getLayoutDirection() == 'ltr') {\n      translateX = '-' + translateX;\n    }\n\n    applyCssTransform(this._tabList.nativeElement, `translate3d(${translateX}, 0, 0)`);\n  }\n/**\n * Sets the distance in pixels that the tab header should be transformed in the X-axis.\n * @param {?} v\n * @return {?}\n */\nset scrollDistance(v: number) {\n    this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v));\n\n    // Mark that the scroll distance has changed so that after the view is checked, the CSS\n    // transformation can move the header.\n    this._scrollDistanceChanged = true;\n\n    this._checkScrollingControls();\n  }\n/**\n * @return {?}\n */\nget scrollDistance(): number { return this._scrollDistance;  }\n/**\n * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n * the end of the list, respectively). The distance to scroll is computed to be a third of the\n * length of the tab list view window.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @param {?} scrollDir\n * @return {?}\n */\n_scrollHeader(scrollDir: ScrollDirection) {\n    const /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\n\n    // Move the scroll distance one-third the length of the tab list's viewport.\n    this.scrollDistance += (scrollDir == 'before' ? -1 : 1) * viewLength / 3;\n  }\n/**\n * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @param {?} labelIndex\n * @return {?}\n */\n_scrollToLabel(labelIndex: number) {\n    const /** @type {?} */ selectedLabel = this._labelWrappers\n        ? this._labelWrappers.toArray()[labelIndex]\n        :  null;\n\n    if (!selectedLabel) { return; }\n\n    // The view length is the visible width of the tab labels.\n    const /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\n\n    let /** @type {?} */ labelBeforePos: number, /** @type {?} */ labelAfterPos: number;\n    if (this._getLayoutDirection() == 'ltr') {\n      labelBeforePos = selectedLabel.getOffsetLeft();\n      labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\n    } else {\n      labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\n      labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\n    }\n\n    const /** @type {?} */ beforeVisiblePos = this.scrollDistance;\n    const /** @type {?} */ afterVisiblePos = this.scrollDistance + viewLength;\n\n    if (labelBeforePos < beforeVisiblePos) {\n      // Scroll header to move label to the before direction\n      this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n    } else if (labelAfterPos > afterVisiblePos) {\n      // Scroll header to move label to the after direction\n      this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n    }\n  }\n/**\n * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n * tab list is wider than the size of the header container, then the pagination controls should\n * be shown.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @return {?}\n */\n_checkPaginationEnabled() {\n    this._showPaginationControls =\n        this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n\n    if (!this._showPaginationControls) {\n      this.scrollDistance = 0;\n    }\n  }\n/**\n * Evaluate whether the before and after controls should be enabled or disabled.\n * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n * before button. If the header is at the end of the list (scroll distance is equal to the\n * maximum distance we can scroll), then disable the after button.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @return {?}\n */\n_checkScrollingControls() {\n    // Check if the pagination arrows should be activated.\n    this._disableScrollBefore = this.scrollDistance == 0;\n    this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n  }\n/**\n * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n * is equal to the difference in width between the tab list container and tab header container.\n * \n * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n * should be called sparingly.\n * @return {?}\n */\n_getMaxScrollDistance(): number {\n    const /** @type {?} */ lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n    const /** @type {?} */ viewLength = this._tabListContainer.nativeElement.offsetWidth;\n    return lengthOfTabList - viewLength;\n  }\n/**\n * Tells the ink-bar to align itself to the current label wrapper\n * @return {?}\n */\nprivate _alignInkBarToSelectedTab(): void {\n    const /** @type {?} */ selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length\n        ? this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement\n        : null;\n\n    this._inkBar.alignToElement(selectedLabelWrapper);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'md-tab-header, mat-tab-header',\n  templateUrl: 'tab-header.html',\n  styleUrls: ['tab-header.css'],\n  encapsulation: ViewEncapsulation.None,\n  host: {\n    'class': 'mat-tab-header',\n    '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',\n    '[class.mat-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\",\n  }\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: Dir, decorators: [{ type: Optional }, ]},\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'_labelWrappers': [{ type: ContentChildren, args: [MdTabLabelWrapper, ] },],\n'_inkBar': [{ type: ViewChild, args: [MdInkBar, ] },],\n'_tabListContainer': [{ type: ViewChild, args: ['tabListContainer', ] },],\n'_tabList': [{ type: ViewChild, args: ['tabList', ] },],\n'selectedIndex': [{ type: Input },],\n'selectFocusedIndex': [{ type: Output },],\n'indexFocused': [{ type: Output },],\n};\n}\n\nfunction MdTabHeader_tsickle_Closure_declarations() {\n/** @type {?} */\nMdTabHeader.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMdTabHeader.ctorParameters;\n/** @type {?} */\nMdTabHeader.propDecorators;\n/** @type {?} */\nMdTabHeader.prototype._labelWrappers;\n/** @type {?} */\nMdTabHeader.prototype._inkBar;\n/** @type {?} */\nMdTabHeader.prototype._tabListContainer;\n/** @type {?} */\nMdTabHeader.prototype._tabList;\n/**\n * The tab index that is focused.\n * @type {?}\n */\nMdTabHeader.prototype._focusIndex;\n/**\n * The distance in pixels that the tab labels should be translated to the left.\n * @type {?}\n */\nMdTabHeader.prototype._scrollDistance;\n/**\n * Whether the header should scroll to the selected index after the view has been checked.\n * @type {?}\n */\nMdTabHeader.prototype._selectedIndexChanged;\n/**\n * Subscription to changes in the layout direction.\n * @type {?}\n */\nMdTabHeader.prototype._directionChange;\n/**\n * Whether the controls for pagination should be displayed\n * @type {?}\n */\nMdTabHeader.prototype._showPaginationControls;\n/**\n * Whether the tab list can be scrolled more towards the end of the tab label list.\n * @type {?}\n */\nMdTabHeader.prototype._disableScrollAfter;\n/**\n * Whether the tab list can be scrolled more towards the beginning of the tab label list.\n * @type {?}\n */\nMdTabHeader.prototype._disableScrollBefore;\n/**\n * The number of tab labels that are displayed on the header. When this changes, the header\n * should re-evaluate the scroll position.\n * @type {?}\n */\nMdTabHeader.prototype._tabLabelCount;\n/**\n * Whether the scroll distance has changed and should be applied after the view is checked.\n * @type {?}\n */\nMdTabHeader.prototype._scrollDistanceChanged;\n/** @type {?} */\nMdTabHeader.prototype._selectedIndex;\n/**\n * Event emitted when the option is selected.\n * @type {?}\n */\nMdTabHeader.prototype.selectFocusedIndex;\n/**\n * Event emitted when a label is focused.\n * @type {?}\n */\nMdTabHeader.prototype.indexFocused;\n/** @type {?} */\nMdTabHeader.prototype._elementRef;\n/** @type {?} */\nMdTabHeader.prototype._dir;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}